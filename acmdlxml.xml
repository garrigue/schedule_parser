<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE event [<!ELEMENT zip_code (#PCDATA)><!ELEMENT url_link_display (#PCDATA)><!ELEMENT url (#PCDATA)><!ELEMENT tracks (track+)><!ELEMENT track (#PCDATA)><!ELEMENT title (#PCDATA)><!ELEMENT timeslot (slot_id?, title, room, date, start_time, end_time, description?, acm_doi?, persons?, tracks?, tags?)><!ELEMENT tags (tag+)><!ELEMENT tag (#PCDATA)><!ELEMENT suffix (#PCDATA)><!ELEMENT subevent_logo_url (#PCDATA)><!ELEMENT subevent_id (#PCDATA)><!ELEMENT subevent (subevent_id?, title, acronym?, subevent_type, description?, room, date, url?, url_link_display?, subevent_logo_url?, acm_doi?, persons?, tracks?, tags?, sponsor?, timeslot*)><!ELEMENT state (#PCDATA)><!ELEMENT start_time (#PCDATA)><!ELEMENT start_date (#PCDATA)><!ELEMENT sponsor (#PCDATA)><!ELEMENT sort_key (#PCDATA)><!ELEMENT slot_id (#PCDATA)><!ELEMENT subevent_type EMPTY><!ATTLIST subevent_type	type (case_study | demonstration | poster | regular | tutorial | workshop) #IMPLIED><!ELEMENT room (#PCDATA)><!ELEMENT role (#PCDATA)><!ELEMENT picture_url (#PCDATA)><!ELEMENT persons (person+)><!ELEMENT person (role, sort_key, first_name, middle_name?, last_name, suffix?, affiliation, acm_profile_id?, email?, bio?, homepage_url?, picture_url?)><!ELEMENT middle_name (#PCDATA)><!ELEMENT location (facility_name, facility_map_url?, address, city, state?, country, zip_code?)><!ELEMENT last_name (#PCDATA)><!ELEMENT homepage_url (#PCDATA)><!ELEMENT first_name (#PCDATA)><!ELEMENT facility_name (#PCDATA)><!ELEMENT facility_map_url (#PCDATA)><!ELEMENT event_type EMPTY><!ATTLIST event_type	type (conference|workshop|symposium) #IMPLIED><!ELEMENT event (event_details, subevent*, timeslot*)><!ELEMENT event_logo_url (#PCDATA)><!ELEMENT event_details (title, acronym, event_type, start_date, end_date, location, description, url?, url_link_display?, event_logo_url?, persons?)><!ELEMENT end_time (#PCDATA)><!ELEMENT end_date (#PCDATA)><!ELEMENT email (#PCDATA)><!ELEMENT description (#PCDATA)><!ELEMENT date (#PCDATA)><!ELEMENT country (#PCDATA)><!ELEMENT city (#PCDATA)><!ELEMENT bio (#PCDATA)><!ELEMENT affiliation (#PCDATA)><!ELEMENT address (#PCDATA)><!ELEMENT acronym (#PCDATA)><!ELEMENT acm_profile_id (#PCDATA)><!ELEMENT acm_doi (#PCDATA)>]>
<event>
  <event_details>
    <title>ICFP 2016</title>
    <acronym>ICFP 2016</acronym>
    <event_type type="conference"/>
    <start_date>2016/09/18</start_date>
    <end_date>2016/09/24</end_date>
    <location>
      <facility_name>Nara Kasugano International Forum</facility_name>
      <address>101 Kasugano</address>
      <city>Nara</city>
      <country>Japan</country>
    </location>
    <description>ICFP 2016 is the 21st ACM SIGPLAN International Conference on Functional Programming.
ICFP provides a forum for researchers and developers to hear about the latest work on the design, implementations, principles, and uses of functional programming. The conference covers the entire spectrum of work, from practice to theory, including its peripheries.
During the conference there will be a Student Research Competition for Graduate and Undergraduate students. Submission deadline: August 3rd, 2016.
Prior to the conference the ICFP Programming Contest will be held from August 5 to August 8.
During the whole ICFP week, the venue will be open from 8:30am for organizers and 8:45am for participants.
Here is a PDF version of the paper program.
The full proceedings of ICFP and workshops can be downloaded here. Please lookup id and password as the registration desk.
Individual paper links are also available from programs on this site.</description>
    <url>http://conf.researchr.org/home/icfp-2016</url>
    <url_link_display>ICFP 2016</url_link_display>
    <persons>
      <person>
        <role>Program Chair in Organizing Committee, ICFP'16 Program Chair in Steering Committee</role>
        <sort_key>1</sort_key>
        <first_name>Eijiro</first_name>
        <last_name>Sumii</last_name>
        <affiliation>Tohoku University</affiliation>
        <bio>Professor in Graduate School of Information Sciences, Tohoku University from May 2014. Main interest includes the theory and applications of programming languages and type systems in a variety of domains including process calculi, partial evaluation, security foundations, and functional programming.</bio>
        <homepage_url>http://www.kb.ecei.tohoku.ac.jp/~sumii/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/eijirosumii/80a91b58-b657-4288-90f2-a5d5986f7774/small.jpg</picture_url>
      </person>
      <person>
        <role>Video Co-Chair in Organizing Committee</role>
        <sort_key>2</sort_key>
        <first_name>Jose</first_name>
        <last_name>Calderon</last_name>
        <affiliation>Galois</affiliation>
        <bio>undefined</bio>
        <picture_url>http://conf.researchr.org/getProfileImage/josecalderon/e4e6ac0b-3f3d-4388-b08d-ee21e3ef5511/small.jpg</picture_url>
      </person>
      <person>
        <role>ICFP'14 Program Chair in Steering Committee</role>
        <sort_key>3</sort_key>
        <first_name>Manuel</first_name>
        <last_name>Chakravarty</last_name>
        <affiliation>University of New South Wales</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cse.unsw.edu.au/~chak/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/manuelchakravarty/12c6a408-4abc-4eb8-9d4b-c4627f17a326/small.jpg</picture_url>
      </person>
      <person>
        <role>Video Chair in Organizing Committee</role>
        <sort_key>4</sort_key>
        <first_name>Iavor</first_name>
        <last_name>Diatchki</last_name>
        <affiliation>Galois, Inc.</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://galois.com/team/iavor-diatchki/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/iavordiatchki1/a98c116d-b41d-4fac-96cb-c83ce3a61d28/small.jpg</picture_url>
      </person>
      <person>
        <role>ICFP'18 General Chair in Steering Committee</role>
        <sort_key>5</sort_key>
        <first_name>Robby</first_name>
        <last_name>Findler</last_name>
        <affiliation>Northwestern University</affiliation>
        <bio>robby@eecs.northwestern.edu</bio>
        <homepage_url>http://www.eecs.northwestern.edu/~robby/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/robbyfindler/28e677e8-d52c-40d1-841d-4b2774afecd1/small.jpg</picture_url>
      </person>
      <person>
        <role>ICFP'15 General Chair in Steering Committee</role>
        <sort_key>6</sort_key>
        <first_name>Kathleen</first_name>
        <last_name>Fisher</last_name>
        <affiliation>Tufts University</affiliation>
        <bio>Kathleen Fisher is Professor in the Computer Science Department at Tufts. Previously, she was a Principal Member of the Technical Staff at AT&amp;amp;T Labs Research, a Consulting Faculty Member in the Computer Science Department at Stanford University, and a program manager at DARPA where she started and managed the HACMS and PPAML programs. Kathleen’s research focuses on advancing the theory and practice of programming languages and on applying ideas from the programming language community to the problem of ad hoc data management. The main thrust of her work has been in domain-specific languages to facilitate programming with massive amounts of ad hoc data, including the Hancock system for efficiently building signatures from massive transaction streams and the PADS system for managing ad hoc data. Recently, she has been exploring synergies between machine learning and programming languages and studying how to apply advances in programming languages to the problem of building more secure systems.
Kathleen is an ACM Fellow. She has served as program chair for FOOL, ICFP, CUFP, and OOPSLA and as General Chair for ICFP 2015. Kathleen is past Chair of the ACM Special Interest Group in Programming Languages (SIGPLAN), past Co-Chair of CRA’s Committee on the Status of Women (CRA-W), and a former editor of the Journal of Functional Programming. She is an Associate Editor for TOPLAS.</bio>
        <homepage_url>http://www.cs.tufts.edu/~kfisher</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/kathleenfisher/04a1b289-f7fe-4e91-b686-6b34a7a45cb2/small.jpg</picture_url>
      </person>
      <person>
        <role>ICFP'18 Program Chair in Steering Committee</role>
        <sort_key>7</sort_key>
        <first_name>Matthew</first_name>
        <last_name>Flatt</last_name>
        <affiliation>University of Utah</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.utah.edu/~mflatt/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/matthewflatt/61fb7ec4-16ed-42de-bbc5-597943a6c87e/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>8</sort_key>
        <first_name>Yosuke</first_name>
        <last_name>Fukuda</last_name>
        <affiliation>Kyoto University</affiliation>
        <bio>undefined</bio>
      </person>
      <person>
        <role>General Co-Chair in Organizing Committee</role>
        <sort_key>9</sort_key>
        <first_name>Jacques</first_name>
        <last_name>Garrigue</last_name>
        <affiliation>Nagoya University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.math.nagoya-u.ac.jp/~garrigue/home.html</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/jacquesgarrigue1/1c6cff5e-3103-4182-96a0-04ceeb96bf14/small.jpg</picture_url>
      </person>
      <person>
        <role>ICFP'16 General Chair in Steering Committee</role>
        <sort_key>10</sort_key>
        <first_name>Jacques</first_name>
        <last_name>Garrigue</last_name>
        <affiliation>Nagoya University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.math.nagoya-u.ac.jp/~garrigue/home.html</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/jacquesgarrigue/bec96eef-5450-49a7-b90f-669ca609e0c7/small.jpg</picture_url>
      </person>
      <person>
        <role>ICFP'17 General Chair in Steering Committee</role>
        <sort_key>11</sort_key>
        <first_name>Jeremy</first_name>
        <last_name>Gibbons</last_name>
        <affiliation>University of Oxford, UK</affiliation>
        <bio>I am Director of the Software Engineering Programme, which offers part-time professional Masters’ degrees in Software Engineering and in Software and Systems Security. I am currently the Chair of Faculty of Computer Science. For the academic years 2008-2010 was also Deputy Director of the Computing Laboratory (now the Department of Computer Science). I am a fellow of Kellogg College. Before taking up this post in 1999, I held lectureships at Oxford Brookes University and the University of Auckland, New Zealand.</bio>
        <homepage_url>http://www.cs.ox.ac.uk/jeremy.gibbons/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/jeremygibbons/e4e44a9a-31d8-4104-abdc-4a28ecbd8618/small.jpg</picture_url>
      </person>
      <person>
        <role>SIGPLAN Chair in Steering Committee</role>
        <sort_key>12</sort_key>
        <first_name>Michael</first_name>
        <last_name>Hicks</last_name>
        <affiliation>University of Maryland, College Park</affiliation>
        <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2). 
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, which is a technique by which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions. 
His recent work has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He is the co-editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
        <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/michaelhicks/3864a29f-1e96-47cc-9798-bcafe0dd0b04/small.jpg</picture_url>
      </person>
      <person>
        <role>Mobile App Chair in Organizing Committee</role>
        <sort_key>13</sort_key>
        <first_name>Reid</first_name>
        <last_name>Holmes</last_name>
        <affiliation>University of Waterloo</affiliation>
        <bio>undefined</bio>
      </person>
      <person>
        <role>Member at large in Steering Committee</role>
        <sort_key>14</sort_key>
        <first_name>John</first_name>
        <last_name>Hughes</last_name>
        <affiliation>Chalmers University of Technology</affiliation>
        <bio>R. John M. Hughes (born ca 1958) is a Swedish computer scientist and professor in the department of Computing Science at the Chalmers University of Technology.
Hughes received his PhD from the University of Oxford in 1984 for the thesis “The Design and Implementation of Programming Languages”.
He is a member of the Functional Programming group at Chalmers, and much of his research relates to the Haskell programming language. He does research in the field of programming languages and is the author of several influential research papers on the subject, including “Why Functional Programming Matters”.[1]
He is also one of the developers of QuickCheck, and cofounder and CEO of QuviQ, which provides the QuickCheck software and offers classes in how to use it.</bio>
        <homepage_url>http://www.cse.chalmers.se/~rjmh/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/johnhughes/3f79ad93-d1b9-44df-92af-0d454dbeae0c/small.jpg</picture_url>
      </person>
      <person>
        <role>ICFP'14 General Chair in Steering Committee</role>
        <sort_key>15</sort_key>
        <first_name>Johan</first_name>
        <last_name>Jeuring</last_name>
        <affiliation>Utrecht University</affiliation>
        <bio>Professor of Software Technology for Learning and Teaching at the Institute of Information and Computing Sciences of Utrecht University (95%), and professor of Software Technology at the School of Computer Science of the Open University (OUNL).
I develop software technology to support learning and teaching, and advanced methods for constructing software.</bio>
        <homepage_url>http://www.staff.science.uu.nl/~jeuri101/homepage/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/johanjeuring/20c79659-6683-4aeb-bd29-3e172bfa3f36/small.jpg</picture_url>
      </person>
      <person>
        <role>ICFP'17 Program Chair in Steering Committee</role>
        <sort_key>16</sort_key>
        <first_name>Mark</first_name>
        <last_name>Jones</last_name>
        <affiliation>Portland State University</affiliation>
        <bio>I am a Professor in the Department of Computer Science in the Maseeh College of Engineering &amp;amp; Computer Science at Portland State University in Portland, Oregon, USA.
My research interests include all aspects of programming language design, implementation, and application. I am particularly interested in the use of advanced programming language technologies for systems programming, and in the development and application of expressive type and module systems that support the construction and certification of secure and reliable software systems.
I am a member of IFIP Working Group 2.8 - Functional Programming.
At various times, I served as a PI for the HASP, Programatica and the Timber projects. (People still ask me about Timbot).
I was the original designer and implementor of the Gofer and Hugs systems. But, after ten years’ work, I no longer maintain or develop those systems.
I live and work in Oregon in the USA. You’d like it here too …</bio>
        <homepage_url>http://web.cecs.pdx.edu/~mpj/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/markjones/cdebe836-fdeb-4fb5-9f2d-181462ee49cf/small.jpg</picture_url>
      </person>
      <person>
        <role>Local Organizer co-Chair in Organizing Committee</role>
        <sort_key>17</sort_key>
        <first_name>Shin-ya</first_name>
        <last_name>Katsumata</last_name>
        <affiliation>Kyoto University, Japan</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.kurims.kyoto-u.ac.jp/~sinya/index-e.html</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/shinyakatsumata/5e61dcb3-bb87-442b-bbd6-0f9a566f939d/small.jpg</picture_url>
      </person>
      <person>
        <role>General Co-Chair in Organizing Committee, ICFP'16 General Chair in Steering Committee</role>
        <sort_key>18</sort_key>
        <first_name>Gabriele</first_name>
        <last_name>Keller</last_name>
        <affiliation>University of New South Wales</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.cse.unsw.edu.au/~keller/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/gabrielekeller/6d6ca9ff-4423-4136-9776-43f25bd5ac29/small.jpg</picture_url>
      </person>
      <person>
        <role>Publicity chair in Organizing Committee, Publicity chair in Steering Committee</role>
        <sort_key>19</sort_key>
        <first_name>Lindsey</first_name>
        <last_name>Kuper</last_name>
        <affiliation>Intel Labs</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.indiana.edu/~lkuper/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/lindseykuper/eceeaffb-2748-4078-aaf9-31e603ef1b68/small.jpg</picture_url>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>20</sort_key>
        <first_name>Andres</first_name>
        <last_name>Löh</last_name>
        <affiliation>Well-Typed LLP</affiliation>
        <bio>Since 2010, I am a partner and Haskell Consultant at Well-Typed LLP.</bio>
        <homepage_url>http://www.andres-loeh.de/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/andresloh/d7276ea5-1b0c-4d50-9ffb-6cadab33f624/small.jpg</picture_url>
      </person>
      <person>
        <role>Member at large in Steering Committee</role>
        <sort_key>21</sort_key>
        <first_name>Yaron</first_name>
        <last_name>Minsky</last_name>
        <affiliation>Jane Street</affiliation>
        <bio>undefined</bio>
        <picture_url>http://conf.researchr.org/getProfileImage/yaronminsky/4b00b8d8-8a54-452b-b11c-e7c269d64554/small.jpg</picture_url>
      </person>
      <person>
        <role>Programming Contest Organiser in Organizing Committee</role>
        <sort_key>22</sort_key>
        <first_name>Keisuke</first_name>
        <last_name>Nakano</last_name>
        <affiliation>The University of Electro-Communications</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://millsmess.cs.uec.ac.jp/~ksk/en/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/keisukenakano/298c7a7e-c06b-489e-9715-cb0a8bba9501/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>23</sort_key>
        <first_name>Yuuki</first_name>
        <last_name>Nishida</last_name>
        <affiliation>Kyoto University</affiliation>
        <bio>undefined</bio>
      </person>
      <person>
        <role>Local Organizer co-Chair in Organizing Committee</role>
        <sort_key>24</sort_key>
        <first_name>Susumu</first_name>
        <last_name>Nishimura</last_name>
        <affiliation>Kyoto University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.math.kyoto-u.ac.jp/~susumu/</homepage_url>
      </person>
      <person>
        <role>ICFP'15 Program Chair in Steering Committee</role>
        <sort_key>25</sort_key>
        <first_name>John</first_name>
        <last_name>Reppy</last_name>
        <affiliation>University of Chicago</affiliation>
        <bio>John Reppy has been exploring issues in language design and implementation since the late 1980’s, with a focus on higher-order, typed, functional languages. He is the inventor of Concurrent ML (CML), co-inventor of the Moby programming language, and has made major contributions to the Standard ML of New Jersey system. He is also the co-editor of the the Standard ML Basis Library specification. His current research focus is on the design and implementation of parallel-programming languages as part of the Manticore and Diderot projects.
He received his PhD from Cornell University in 1992 and worked at Bell Laboratories, Murray Hill for eleven years. He is currently a professor of Computer Science and a Senior Fellow of the Computation Institute at the University of Chicago. From August 2011 through August 2013, he served as a Program Director at the National Science Foundation where he helped start the Exploiting Parallelism and Scalability program (XPS).</bio>
        <homepage_url>http://people.cs.uchicago.edu/~jhr/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/johnreppy/7c9e332e-ee11-4f40-82ee-8864028ba80b/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>26</sort_key>
        <first_name>Gabriel</first_name>
        <last_name>Scherer</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>(this profile is inactive, it is a duplicate.)</bio>
        <picture_url>http://conf.researchr.org/getProfileImage/gabrielscherer1/d070028f-9382-4b21-a799-054024c2d718/small.jpg</picture_url>
      </person>
      <person>
        <role>Member at large in Steering Committee</role>
        <sort_key>27</sort_key>
        <first_name>Michael</first_name>
        <last_name>Sperber</last_name>
        <affiliation>Active Group GmbH</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://deinprogramm.de/sperber/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/michaelsperber/e0008500-aa96-40e3-87f9-afe454474878/small.jpg</picture_url>
      </person>
      <person>
        <role>Member at large in Steering Committee</role>
        <sort_key>28</sort_key>
        <first_name>Wouter</first_name>
        <last_name>Swierstra</last_name>
        <affiliation>University of Utrecht</affiliation>
        <bio>After studying Mathematics and Computer Science at the University of Utrecht, I did my PhD under supervision of Thorsten Altenkirch at the University of Nottingham’s Functional Programming Lab. I worked as a post-doc at Chalmers University of Technology, before moving back to the Netherlands to work at Vector Fabrics, a high-tech startup that uses functional programming to facilitate the design of embedded systems. After this brief stint in industry, I returned to academia as a postdoc in the Foundations Group at the Radboud University Nijmegen.</bio>
        <homepage_url>http://www.staff.science.uu.nl/~swier004/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/wouterswierstra/1db000a0-20ed-4c0d-b00c-d467bf461548/small.jpg</picture_url>
      </person>
      <person>
        <role>SIGPLAN Vice Chair in Steering Committee</role>
        <sort_key>29</sort_key>
        <first_name>Peter</first_name>
        <last_name>Thiemann</last_name>
        <affiliation>University of Freiburg, Germany</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www2.informatik.uni-freiburg.de/~thiemann/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/peterthiemann/e05f6038-4b5e-4c38-91bb-a460b5d8d756/small.jpg</picture_url>
      </person>
      <person>
        <role>Industrial Relations Chair in Organizing Committee</role>
        <sort_key>30</sort_key>
        <first_name>Ryan</first_name>
        <last_name>Trinkle</last_name>
        <affiliation>Obsidian Systems LLC</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://obsidian.systems/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/ryantrinkle/8da7a5a4-ba97-4d65-bbad-058f3f5a93dc/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Research Competition Chair in Organizing Committee</role>
        <sort_key>31</sort_key>
        <first_name>David</first_name>
        <last_name>Van Horn</last_name>
        <affiliation>University of Maryland, USA</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.cs.umd.edu/~dvanhorn/</homepage_url>
        <picture_url>http://conf.researchr.org/getProfileImage/davidvanhorn/767593d7-5911-4b7b-8895-518920ea97a7/small.jpg</picture_url>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>32</sort_key>
        <first_name>Nicolas</first_name>
        <last_name>Wu</last_name>
        <affiliation>University of Bristol, UK</affiliation>
        <bio>undefined</bio>
        <picture_url>http://conf.researchr.org/getProfileImage/nicolaswu/b942d968-9bf7-4c15-9110-828a9d048664/small.jpg</picture_url>
      </person>
    </persons>
  </event_details>
  <subevent>
    <subevent_id>b1888e72-535c-463c-b850-97c49835dc68</subevent_id>
    <title>Reports: ICFP Program Chair Report and Contest Presentation</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/20</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-ICFP-2016-Report</url>
    <url_link_display>Reports</url_link_display>
    <tracks>
      <track>Reports</track>
    </tracks>
    <timeslot>
      <slot_id>2b0d6c3b-d675-4640-a2e9-a0942107f634</slot_id>
      <title>Program Chair Report (Eijiro Sumii)</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>17:40</start_time>
      <end_time>17:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>Reports</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cd30b846-8ae6-44d3-bbc9-a7c36dd97cd0</slot_id>
      <title>Programming Contest Presentation (Keisuke Nakano)</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>17:50</start_time>
      <end_time>18:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Reports</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e769d444-10dc-4eca-b312-0a72943f6025</subevent_id>
    <title>Reports: SRC Awards and Closing</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/21</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-ICFP-2016-Report</url>
    <url_link_display>Reports</url_link_display>
    <tracks>
      <track>Reports</track>
    </tracks>
    <timeslot>
      <slot_id>226c2eb1-7e6e-427c-ab21-e9652eec6b09</slot_id>
      <title>SRC Awards (David Van Horn)</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>17:40</start_time>
      <end_time>17:55</end_time>
      <description>undefined</description>
      <tracks>
        <track>Reports</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8f680b79-0b17-4aed-9505-80ac93b403b7</slot_id>
      <title>ICFP 2016 Closing / ICFP 2017 Presentation</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>17:55</start_time>
      <end_time>18:10</end_time>
      <description>undefined</description>
      <tracks>
        <track>Reports</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>635585e0-020d-498c-978e-c6e023a8af5a</subevent_id>
    <title>Keynote Talks: Keynote 2</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/20</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-keynote-talks</url>
    <url_link_display>ICFP 2016 Keynote Talks</url_link_display>
    <tracks>
      <track>ICFP 2016 Keynote Talks</track>
    </tracks>
    <timeslot>
      <slot_id>92f62cbf-1325-4e9f-8759-55be4af4a490</slot_id>
      <title>Journey to Find Bugs in JavaScript Web Applications in the Wild</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>09:15</start_time>
      <end_time>10:15</end_time>
      <description>Analyzing real-world JavaScript web applications is a challenging task. On top of understanding the semantics of JavaScript, it requires modeling of web documents, platform objects, and interactions between them. Not only the JavaScript language itself but also its usage patterns are extremely dynamic. JavaScript can generate code and run it during evaluation, and most web applications load JavaScript code dynamically. Such dynamic characteristics of JavaScript web applications make pure static analysis approaches inapplicable.
In this talk, we present our attempts to analyze JavaScript web applications in the wild mostly statically using various approaches. From pure JavaScript programs to JavaScript web applications using platform-specific libraries and dynamic code loading, we explain technical challenges in analyzing each of them and how we built an open-source analysis framework for JavaScript, SAFE, that addresses the challenges incrementally.
In spite of active research accomplishments in analysis of JavaScript web applications, many issues still remain to be resolved such as events, callback functions, and hybrid web applications. We discuss possible future research directions and open challenges.
Speaker Bio
Sukyoung Ryu is an associate professor in the School of Computing at Korea Advanced Institute of Science and Technology (KAIST). Her research interests are in programming languages and program analysis. Recently, her group has been focusing on analysis of and bug finding in JavaScript web applications by developing an open-source tool called SAFE, which is being used in both academia and industry. She is a recipient of various awards including the Google Faculty Research Award. She received her Ph.D. in Computer Science from KAIST, worked at Harvard University and Sun Microsystems Laboratories.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sukyoung</first_name>
          <last_name>Ryu</last_name>
          <affiliation>KAIST</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plrg.kaist.ac.kr/ryu</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/sukyoungryu/3bdcd232-f3d4-4610-9953-30b513926e54/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ICFP 2016 Keynote Talks</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fdac57e3-8a88-4e2c-9160-443fcc2458fe</subevent_id>
    <title>Keynote Talks: Keynote 1</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/19</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-keynote-talks</url>
    <url_link_display>ICFP 2016 Keynote Talks</url_link_display>
    <tracks>
      <track>ICFP 2016 Keynote Talks</track>
    </tracks>
    <timeslot>
      <slot_id>d461fd04-4386-4b52-be4f-66fed09b2b7f</slot_id>
      <title>TensorFlow: Learning Functions at Scale</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>09:15</start_time>
      <end_time>10:15</end_time>
      <description>TensorFlow is a machine learning system that operates at large scale and in heterogeneous environments. Its computational model is based on dataflow graphs with mutable state. Graph nodes may be mapped to different machines in a cluster, and within each machine to CPUs, GPUs, and other devices. TensorFlow supports a variety of applications, but it particularly targets training and inference with deep neural networks. It serves as a platform for research and for deploying machine learning systems across many areas, such as speech recognition, computer vision, robotics, information retrieval, and natural language processing.
In this talk, we describe TensorFlow and outline some of its applications. We also discuss the question of what TensorFlow and deep learning may have to do with functional programming. Although TensorFlow is not purely functional, many of its uses are concerned with optimizing functions (during training), then with applying those functions (during inference). These functions are defined as compositions of simple primitives (as is common in functional programming), with internal data representations that are learned rather than manually designed.
TensorFlow is joint work with many other people in the Google Brain team and elsewhere. More information is available at tensorflow.org.
Speaker Bio
Mart&amp;iacute;n Abadi is a Principal Scientist at Google. He is also a Professor Emeritus at the University of California at Santa Cruz, where was a Professor in the Computer Science Department till 2013. He has held an annual Chair at the Coll&amp;egrave;ge de France, has taught at Stanford University and the University of California at Berkeley, and has worked at Digital’s System Research Center, Microsoft Research Silicon Valley, and other industrial research labs. He received his Ph.D. at Stanford University in 1987. His research is mainly on computer and network security, programming languages, and specification and verification methods. It has been recognized with the Outstanding Innovation Award of the ACM Special Interest Group on Security, Audit and Control and with the Hall of Fame Award of the ACM Special Interest Group on Operating Systems, among other awards. He is a Fellow of the Association for Computing Machinery and of the American Association for the Advancement of Science (AAAS). He holds a doctorate honoris causa from &amp;Eacute;cole normale sup&amp;eacute;rieure de Cachan.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Abadi</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://users.soe.ucsc.edu/~abadi/home.html</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/martinabadi/082202e6-c10a-45ed-b843-746524c2192b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ICFP 2016 Keynote Talks</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>51050a73-15d3-4632-a8f2-4deec19121fb</subevent_id>
    <title>Receptions: Banquet and SIGPLAN Awards</title>
    <subevent_type type="regular"/>
    <room>Hotel Nikko</room>
    <date>2016/09/20</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-reception</url>
    <url_link_display>Receptions</url_link_display>
    <tracks>
      <track>Receptions</track>
    </tracks>
    <timeslot>
      <slot_id>d6d10fa2-628c-4e89-907e-7caa3b1da54e</slot_id>
      <title>Reception</title>
      <room>Hotel Nikko</room>
      <date>2016/09/20</date>
      <start_time>19:00</start_time>
      <end_time>21:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Receptions</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>44974479-c84b-4bae-823d-da36cf306efa</subevent_id>
    <title>Receptions: Welcome Reception with SRC Posters</title>
    <subevent_type type="regular"/>
    <room>Reception Hall 1</room>
    <date>2016/09/19</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-reception</url>
    <url_link_display>Receptions</url_link_display>
    <tracks>
      <track>Receptions</track>
    </tracks>
    <timeslot>
      <slot_id>ce658958-11c9-4e89-ae56-3043aed7b90a</slot_id>
      <title>Reception</title>
      <room>Reception Hall 1</room>
      <date>2016/09/19</date>
      <start_time>18:30</start_time>
      <end_time>20:30</end_time>
      <description>undefined</description>
      <tracks>
        <track>Receptions</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b87fb9c2-7701-44d5-a54d-ab3516c4d208</subevent_id>
    <title>Keynote Talks: Keynote 3</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/21</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-keynote-talks</url>
    <url_link_display>ICFP 2016 Keynote Talks</url_link_display>
    <tracks>
      <track>ICFP 2016 Keynote Talks</track>
    </tracks>
    <timeslot>
      <slot_id>46a1f42b-8874-4749-b3d9-a8ece196a7e9</slot_id>
      <title>A Functional Programmer's Guide to Homotopy Type Theory</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>09:15</start_time>
      <end_time>10:15</end_time>
      <description>Dependent type theories are functional programming languages with types rich enough to do computer-checked mathematics and software verification. Homotopy type theory is a recent area of work that connects dependent type theory to the mathematical disciplines of homotopy theory and higher-dimensional category theory. From a programming point of view, these connections have revealed that all types in dependent type theory support a certain generic program that had not previously been exploited. Specifically, each type can be equipped with computationally relevant witnesses of equality of elements of that type, and all types support a generic program that transports elements along these equalities. One mechanism for equipping types with non-trivial witnesses of equality is Voevodsky’s univalence axiom, which implies that equality of types themselves is witnessed by type isomorphism. Another is higher inductive types, an extended datatype schema that allows identifications between different datatype constructors. While these new mechanisms were originally formulated as axiomatic extensions of type theory, recent work has investigated their computational meaning, leading to the development of new programming languages that better support them. In this talk, I will illustrate what univalence and higher inductive types mean in programming terms. I will also discuss how studying some related semantic settings can reveal additional structure on types; for example, moving from groupoids (categories where all maps are invertible) to general categories yields an account of coercions instead of equalities. Overall, I hope to convey some of the beauty and richness of these connections between disciplines, which we are just beginning to understand.
Speaker Bio
Dan Licata is an assistant professor of computer science at Wesleyan University. He received his PhD from Carnegie Mellon University in 2011, and was a postdoc at the Institute for Advanced Study in 2012-2013. His PhD thesis, on programming domain-specific specification logics in type theory, won the 2012 FoLLI E.W. Beth Dissertation Award. Two of his current projects investigate extensions and applications of homotopy type theory, and cost analysis of functional programs. He designed and regularly teaches an introductory functional programming course that integrates parallel thinking throughout the semester.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Dan</first_name>
          <last_name>Licata</last_name>
          <affiliation>Wesleyan University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dlicata.web.wesleyan.edu</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/danlicata/dbade80f-98b4-4022-a768-aa16c35b21d1/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ICFP 2016 Keynote Talks</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7ab64c46-05d3-4fc9-922b-ee803d806108</subevent_id>
    <title>Receptions: Industrial Reception</title>
    <subevent_type type="regular"/>
    <room>Reception Hall 2</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-reception</url>
    <url_link_display>Receptions</url_link_display>
    <tracks>
      <track>Receptions</track>
    </tracks>
    <timeslot>
      <slot_id>564119df-f67b-47c3-a4e0-b5b90cde6224</slot_id>
      <title>All ICFP participants are welcome</title>
      <room>Reception Hall 2</room>
      <date>2016/09/22</date>
      <start_time>18:30</start_time>
      <end_time>20:30</end_time>
      <description>undefined</description>
      <tracks>
        <track>Receptions</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dc7d36d9-ea74-4a0f-a474-9284a084e564</subevent_id>
    <title>Scheme: Functional Programming</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/scheme-2016-papers</url>
    <url_link_display>Scheme</url_link_display>
    <tracks>
      <track>Scheme</track>
    </tracks>
    <timeslot>
      <slot_id>7e3f6c6f-0a33-4881-9603-525393483b76</slot_id>
      <title>Multi-purpose web framework design based on websocket over HTTP Gateway</title>
      <room>Conference Room 2</room>
      <date>2016/09/18</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mu</first_name>
          <last_name>Lei</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Scheme</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9c73cfc6-8d83-4e5a-ab5c-027d5d12a189</slot_id>
      <title>Function compose, Type cut, And the Algebra of logic</title>
      <room>Conference Room 2</room>
      <date>2016/09/18</date>
      <start_time>15:30</start_time>
      <end_time>16:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuheng</first_name>
          <last_name>Xie</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Scheme</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ec9addda-3544-46d2-a044-8f8e80a9f082</subevent_id>
    <title>TyDe: Session One</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/tyde-2016-papers</url>
    <url_link_display>Type-driven Development</url_link_display>
    <tracks>
      <track>Type-driven Development</track>
    </tracks>
    <timeslot>
      <slot_id>78f2d3fe-e025-4eb8-acdb-c88854aef436</slot_id>
      <title>APLicative Programming with Naperian Functors</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>09:35</start_time>
      <end_time>09:55</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Gibbons</last_name>
          <affiliation>University of Oxford, UK</affiliation>
          <bio>I am Director of the Software Engineering Programme, which offers part-time professional Masters’ degrees in Software Engineering and in Software and Systems Security. I am currently the Chair of Faculty of Computer Science. For the academic years 2008-2010 was also Deputy Director of the Computing Laboratory (now the Department of Computer Science). I am a fellow of Kellogg College. Before taking up this post in 1999, I held lectureships at Oxford Brookes University and the University of Auckland, New Zealand.</bio>
          <homepage_url>http://www.cs.ox.ac.uk/jeremy.gibbons/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/jeremygibbons/e4e44a9a-31d8-4104-abdc-4a28ecbd8618/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9b8a948b-2a65-4213-be01-6b76ec0bacf2</slot_id>
      <title>Choose Your Own Derivative</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>09:55</start_time>
      <end_time>10:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jennifer</first_name>
          <last_name>Paykin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Antal</first_name>
          <last_name>Spector-Zabusky</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kenneth</first_name>
          <last_name>Foner</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bddecaa4-02b0-4f7d-a8fb-870a6cfce3f7</slot_id>
      <title>Opening</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>09:15</start_time>
      <end_time>09:35</end_time>
      <description>undefined</description>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>794b6dad-a6ad-4ee2-8579-96e7290bfa4d</subevent_id>
    <title>PLMW: 1</title>
    <subevent_type type="regular"/>
    <room>Conference Room 5</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/PLMW-ICFP-2016</url>
    <url_link_display>PLMW</url_link_display>
    <tracks>
      <track>PLMW</track>
    </tracks>
    <timeslot>
      <slot_id>e7b63727-91c8-483e-8a80-5943ddb34de2</slot_id>
      <title> Welcome to ICFP!</title>
      <room>Conference Room 5</room>
      <date>2016/09/18</date>
      <start_time>09:15</start_time>
      <end_time>09:45</end_time>
      <description>This presentation serves as an introduction to ICFP for students attending PLMW@ICFP.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kathleen</first_name>
          <last_name>Fisher</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>Kathleen Fisher is Professor in the Computer Science Department at Tufts. Previously, she was a Principal Member of the Technical Staff at AT&amp;amp;T Labs Research, a Consulting Faculty Member in the Computer Science Department at Stanford University, and a program manager at DARPA where she started and managed the HACMS and PPAML programs. Kathleen’s research focuses on advancing the theory and practice of programming languages and on applying ideas from the programming language community to the problem of ad hoc data management. The main thrust of her work has been in domain-specific languages to facilitate programming with massive amounts of ad hoc data, including the Hancock system for efficiently building signatures from massive transaction streams and the PADS system for managing ad hoc data. Recently, she has been exploring synergies between machine learning and programming languages and studying how to apply advances in programming languages to the problem of building more secure systems.
Kathleen is an ACM Fellow. She has served as program chair for FOOL, ICFP, CUFP, and OOPSLA and as General Chair for ICFP 2015. Kathleen is past Chair of the ACM Special Interest Group in Programming Languages (SIGPLAN), past Co-Chair of CRA’s Committee on the Status of Women (CRA-W), and a former editor of the Journal of Functional Programming. She is an Associate Editor for TOPLAS.</bio>
          <homepage_url>http://www.cs.tufts.edu/~kfisher</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/kathleenfisher/04a1b289-f7fe-4e91-b686-6b34a7a45cb2/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PLMW</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e95e8f40-fd0b-4100-8159-0c3ce3e18672</slot_id>
      <title>Rust: PL research in industry</title>
      <room>Conference Room 5</room>
      <date>2016/09/18</date>
      <start_time>09:45</start_time>
      <end_time>10:15</end_time>
      <description>Rust is a new language, sponsored by Mozilla, with the core goal of safe and productive systems programming. It’s a language developed industrially, with ambitions for widespread adoption. But it’s also a language deeply informed by PL research, including substructural types, the Cyclone project, Haskell’s type classes, and Scheme macros. And it’s built by a team that mixes PL PhDs with dyed-in-the-wool engineers.
In this talk, I’ll cover some of my experiences as one of those PL PhDs. We’ll tour some of the core features of Rust, tracing the research lineage and seeing what evolution was needed to make them work at scale. We’ll discuss the tough decisions around shipping the language without yet having a soundness proof, and further tough decisions about how to handle soundness fixes. We’ll talk about the way that Rust’s ongoing development is done completely in the open, and how that relates to working in an academic setting. And finally, I’ll mention some of the open research problems around Rust – which runs the gamut from memory models, specification, soundness, API design, to type theory and more.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Turon</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PLMW</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b7caa52d-4c3c-46cf-8588-57b570acd709</subevent_id>
    <title>TyDe: Session Three</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/tyde-2016-papers</url>
    <url_link_display>Type-driven Development</url_link_display>
    <tracks>
      <track>Type-driven Development</track>
    </tracks>
    <timeslot>
      <slot_id>02b51176-2015-4433-b473-50a4b7d690ee</slot_id>
      <title>Liberating Effects with Rows and Handlers</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Hillerström</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Lindley</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/slindley/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/samlindley/32dd34f2-c14b-412f-811e-449bbff76c7f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1fe2ebdf-3195-43d9-88ca-d8603bf1ddc1</slot_id>
      <title>Applications of Applicative Proof Search</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Liam</first_name>
          <last_name>O'Connor</last_name>
          <affiliation>UNSW, Australia</affiliation>
          <bio>Liam is a PhD student at UNSW Australia working on Trustworthy Systems projects with Data61 at CSIRO (formerly known as NICTA). His PhD work focuses on the use of linear typed languages to provide easy-to-reason-about semantics for formal verification of operating system components. More broadly, his research interests include automated proof and reasoning, particularly in the context of dependently typed programming languages, type inference, static analysis, and concurrency.</bio>
          <homepage_url>http://liamoc.net</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/liamoconnor/62bc9dba-ffaf-41b7-94db-85d112d608ea/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e210e2cc-0505-459f-bb75-6de2ba0ad8e6</subevent_id>
    <title>Scheme: Invited Talk</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/scheme-2016-papers</url>
    <url_link_display>Scheme</url_link_display>
    <tracks>
      <track>Scheme</track>
    </tracks>
    <timeslot>
      <slot_id>00976b44-54c1-445d-a15a-a84a529ee3aa</slot_id>
      <title>A verified Lisp implementation for a verified theorem prover</title>
      <room>Conference Room 2</room>
      <date>2016/09/18</date>
      <start_time>09:25</start_time>
      <end_time>10:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Magnus O.</first_name>
          <last_name>Myreen</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Scheme</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>53f1ae19-2f13-4c86-a7b7-cb92a76817c9</slot_id>
      <title>Opening Remarks</title>
      <room>Conference Room 2</room>
      <date>2016/09/18</date>
      <start_time>09:15</start_time>
      <end_time>09:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alex</first_name>
          <last_name>Shinn</last_name>
          <affiliation>Indeed.com</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://synthcode.com/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/alexshinn/b1095018-2d9a-4e9e-bfde-d8f2b3d1488a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Scheme</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>71863b60-e6d2-4f02-b628-68f88f6cc283</subevent_id>
    <title>Scheme: Scheming</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/scheme-2016-papers</url>
    <url_link_display>Scheme</url_link_display>
    <tracks>
      <track>Scheme</track>
    </tracks>
    <timeslot>
      <slot_id>392c2346-bfae-42f4-baf5-112ebf3c55eb</slot_id>
      <title>Ghosts in the machine</title>
      <room>Conference Room 2</room>
      <date>2016/09/18</date>
      <start_time>11:45</start_time>
      <end_time>12:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Szmulewicz</last_name>
          <affiliation>None</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://danielsz.github.io/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/danielszmulewicz/f956fe2a-d12f-4c87-ab40-cd1aee1379dc/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Scheme</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b2a2fa74-2762-40eb-95d8-84363778d509</slot_id>
      <title>A Scheme concurrency library</title>
      <room>Conference Room 2</room>
      <date>2016/09/18</date>
      <start_time>10:45</start_time>
      <end_time>11:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Takashi</first_name>
          <last_name>Kato</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Scheme</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bbc00ccb-f785-432e-aa9f-28df4809c3b3</slot_id>
      <title>Nash: a tracing JIT for Extension Language</title>
      <room>Conference Room 2</room>
      <date>2016/09/18</date>
      <start_time>11:15</start_time>
      <end_time>11:45</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Atsuro</first_name>
          <last_name>Hoshino</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Scheme</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ee34727e-8a73-448c-b7e9-e1a39536be79</subevent_id>
    <title>PLMW: 2</title>
    <subevent_type type="regular"/>
    <room>Conference Room 5</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/PLMW-ICFP-2016</url>
    <url_link_display>PLMW</url_link_display>
    <tracks>
      <track>PLMW</track>
    </tracks>
    <timeslot>
      <slot_id>46da7cdc-be7c-40a2-8ac8-38a28b39cbdf</slot_id>
      <title>Some Types of Types</title>
      <room>Conference Room 5</room>
      <date>2016/09/18</date>
      <start_time>11:30</start_time>
      <end_time>12:15</end_time>
      <description>We review some of the many uses of types, including simple, ad hoc and parametric polymorphic, dependent, effect, and linear types, and touching on contributions by Russell, Church, Curry, Turing, Backus, Hoare, Wirth, Strachey, Scott, Hindley, Milner, Reynolds, Girard, Plotkin, Mitchell, Cardelli, Wegner, and Martin Lof.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Philip</first_name>
          <last_name>Wadler</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>Philip Wadler is Professor of Theoretical Computer Science at the University of Edinburgh. He is an ACM Fellow and a Fellow of the Royal Society of Edinburgh, past chair of ACM SIGPLAN, past holder of a Royal Society-Wolfson Research Merit Fellowship, and a winner of the POPL Most Influential Paper Award. Previously, he worked or studied at Stanford, Xerox Parc, CMU, Oxford, Chalmers, Glasgow, Bell Labs, and Avaya Labs, and visited as a guest professor in Copenhagen, Sydney, and Paris. He has an h-index of 60, with more than 18,000 citations to his work according to Google Scholar. He contributed to the designs of Haskell, Java, and XQuery, and is a co-author of Introduction to Functional Programming, XQuery from the Experts and Generics and Collections in Java. He has delivered invited talks in locations ranging from Aizu to Zurich.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/wadler/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/philipwadler/4d28d9ea-0064-4f0f-aa7e-f3cc4d762a78/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PLMW</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a17a5520-97ec-4dea-a428-08432e5e1887</slot_id>
      <title>Basic Mechanics of Operational Semantics</title>
      <room>Conference Room 5</room>
      <date>2016/09/18</date>
      <start_time>10:45</start_time>
      <end_time>11:30</end_time>
      <description>Programming language research is largely the study of properties of programs, but reasoning about such properties presupposes programs have some meaning. Consequently, most papers in the area of programming languages start by establishing what programs mean, i.e., they define a semantics. There are several forms of semantics, but the most common form found in current PL papers is that of operational semantics. Operational semantics defines the meaning of a program by explaining its behavior in terms of a hypothetical computer which performs the set of actions which constitute the evaluation of that program. These “hypothetical computers” can range from the very abstract, bearing little resemblance to what you might think of as a physical computer, to the very concrete, amenable to implementation on common hardware.
The goal of this talk will be to convey the basic machinery of operational semantics needed to read and understand ICFP papers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Van Horn</last_name>
          <affiliation>University of Maryland, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.umd.edu/~dvanhorn/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/davidvanhorn/767593d7-5911-4b7b-8895-518920ea97a7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PLMW</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e15bb484-fbb5-4a1a-b994-a637c1dd7e46</subevent_id>
    <title>PLMW: 5</title>
    <subevent_type type="regular"/>
    <room>Conference Room 5</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/PLMW-ICFP-2016</url>
    <url_link_display>PLMW</url_link_display>
    <tracks>
      <track>PLMW</track>
    </tracks>
    <timeslot>
      <slot_id>0f0f454a-43b2-4b11-8bb0-12dfa2fbcbe0</slot_id>
      <title>Principle and Practice of OCaml Type Debugger</title>
      <room>Conference Room 5</room>
      <date>2016/09/18</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>It is not always easy to correct a type error especially for novice programmers. When a type error occurs, the compiler shows a type error message, but often, it does not show the true cause of the type error. Why? Because it is impossible in general. Without knowing the intention of the programmer, the compiler cannot choose a single cause among multiple possible causes of the type error.
To locate the true cause of a type error, we have built an interactive type debugger for OCaml that incorporates programmer’s intention. When a type error occurs, the type debugger asks a series of questions to the programmer. By correctly answering these questions, we are lead to the true source of the type error.
In this talk, I will first introduce the principle of the type debugger and show how a simple but crucial idea leads to a practicable type debugger. I then describe requirements and challenges for such a tool to be effective in the real use cases, such as in a classroom.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kenichi</first_name>
          <last_name>Asai</last_name>
          <affiliation>Ochanomizu University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pllab.is.ocha.ac.jp/~asai/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/kenichiasai/4cd309f4-1d81-4c04-acbb-6ae518baa52b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PLMW</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6c1ee6b5-d3df-4551-bd1d-5d9eaae7eecc</slot_id>
      <title>Unaccustomed as I am to public speaking</title>
      <room>Conference Room 5</room>
      <date>2016/09/18</date>
      <start_time>17:30</start_time>
      <end_time>18:00</end_time>
      <description>A key part of life as a researcher is conveying your ideas to an audience at a conference or workshop, in a way that engages and excites them. Giving such a talk is quite different from writing a paper, or giving a lecture as part of a course, and it must be approached in a different way. In this presentation-by-example I’ll explain my own approach, and try to help you avoid a number of (surprisingly common!) pitfalls.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Hughes</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>R. John M. Hughes (born ca 1958) is a Swedish computer scientist and professor in the department of Computing Science at the Chalmers University of Technology.
Hughes received his PhD from the University of Oxford in 1984 for the thesis “The Design and Implementation of Programming Languages”.
He is a member of the Functional Programming group at Chalmers, and much of his research relates to the Haskell programming language. He does research in the field of programming languages and is the author of several influential research papers on the subject, including “Why Functional Programming Matters”.[1]
He is also one of the developers of QuickCheck, and cofounder and CEO of QuviQ, which provides the QuickCheck software and offers classes in how to use it.</bio>
          <homepage_url>http://www.cse.chalmers.se/~rjmh/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/johnhughes/3f79ad93-d1b9-44df-92af-0d454dbeae0c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PLMW</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0d4fce26-ec4c-4d90-8c8f-10a856a292ce</subevent_id>
    <title>TyDe: Session Two</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/tyde-2016-papers</url>
    <url_link_display>Type-driven Development</url_link_display>
    <tracks>
      <track>Type-driven Development</track>
    </tracks>
    <timeslot>
      <slot_id>09a3c611-d97c-4591-8a06-22739a0feeaf</slot_id>
      <title>Generic partially-static data</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>11:35</start_time>
      <end_time>11:55</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Kaloper-Mersinjak</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Yallop</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~jdy22/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2f6925b3-f72a-4595-b401-5ea8dc8fc05b</slot_id>
      <title>Bidirectional Transformations are Proof-Relevant Bisimulations</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>11:55</start_time>
      <end_time>12:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>McKinna</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5a674156-f323-475b-9ad7-f59d1c123a14</slot_id>
      <title>Generic diff3 for Algebraic Datatypes</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>10:45</start_time>
      <end_time>11:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marco</first_name>
          <last_name>Vassena</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e68a91d0-1c91-43f1-85ff-5d9658c27306</slot_id>
      <title>Programming Assistance for Type-directed Programming</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>11:15</start_time>
      <end_time>11:35</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Peter-Michael</first_name>
          <last_name>Osera</last_name>
          <affiliation>Grinnell College</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.grinnell.edu/~osera</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/petermichaelosera/e150f329-fb7d-4641-80e6-a3e97bbe9e11/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5a075b38-0e44-4870-97ac-ea65b50be428</subevent_id>
    <title>TyDe: Session Five</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/tyde-2016-papers</url>
    <url_link_display>Type-driven Development</url_link_display>
    <tracks>
      <track>Type-driven Development</track>
    </tracks>
    <timeslot>
      <slot_id>a8642912-e780-469b-a6f7-af7b5fb7f052</slot_id>
      <title>Parameterized Extensible Effects and Session Types</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>17:00</start_time>
      <end_time>17:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oleg</first_name>
          <last_name>Kiselyov</last_name>
          <affiliation>Tohoku University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://okmij.org/ftp/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/olegkiselyov/575daa05-880d-4f2f-b085-acbece1d264e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c8bd31e3-4028-48b9-84d1-a037f91dbe10</slot_id>
      <title>An Agda formalisation of the transitive closure of block matrices</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>17:20</start_time>
      <end_time>17:40</end_time>
      <description>We define a block based matrix representation in Agda and lift various algebraic structures (semi-near-rings, semi-rings and closed semi-rings) to matrices in order to verify algorithms that can be implemented using the closure operation in a semi-ring.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Patrik</first_name>
          <last_name>Jansson</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.chalmers.se/en/Staff/Pages/patrik-jansson.aspx</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/patrikjansson/14102235-c1e2-4283-8f8b-20cf67eb7d91/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Adam</first_name>
          <last_name>Sandberg Eriksson</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>03c2cb40-5f51-4217-9bd3-e2b2eb6993f9</subevent_id>
    <title>PLMW: 4</title>
    <subevent_type type="regular"/>
    <room>Conference Room 5</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/PLMW-ICFP-2016</url>
    <url_link_display>PLMW</url_link_display>
    <tracks>
      <track>PLMW</track>
    </tracks>
    <timeslot>
      <slot_id>b3dd5511-e89d-4621-934f-2c42bbc0c8fa</slot_id>
      <title>How to Write Papers So People Can Read Them</title>
      <room>Conference Room 5</room>
      <date>2016/09/18</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>Learning to write well is an essential part of becoming a successful researcher. Unfortunately, many researchers find it very hard to write well because they do not know how to view their text from the perspective of the reader. In this talk, we present a simple set of principles for good writing, based on an understanding of how readers process information. Unlike such platitudes as “Be clear” or “Omit needless words”, our principles are constructive: one can easily check whether a piece of text satisfies them, and if it does not, the principles suggest concrete ways to improve it.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Derek</first_name>
          <last_name>Dreyer</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~dreyer</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/derekdreyer/fa38ae17-ad43-4448-b1d5-20bb6e281012/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PLMW</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b577a0b2-5fc3-42a9-886f-a5e2456f3241</slot_id>
      <title>Program Transformations for Developing Efficient and Correct Programs with Ease</title>
      <room>Conference Room 5</room>
      <date>2016/09/18</date>
      <start_time>15:30</start_time>
      <end_time>16:00</end_time>
      <description>A goal of programming language researches is to establish a method of developing efficient and correct programs with ease. However, it is generally difficult to chase these rabbits. Efficient programs are usually complicated and hence difficult to see correctness. In this talk, we study an approach to this problem based on program transformations. Program transformations enable us to derive complex programs from naive but apparently correct ones in a “correct by construction” manner. We see effectiveness of program transformations through examples, including deforestation, program inversion, and program parallelization.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Akimasa</first_name>
          <last_name>Morihata</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.graco.c.u-tokyo.ac.jp/labs/morihata/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/akimasamorihata/c0883451-c2d1-42da-8e5d-d6e6699b8c8e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PLMW</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>20dd4296-b805-4ea6-b3ae-667753365832</subevent_id>
    <title>Scheme: Scheming</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/scheme-2016-papers</url>
    <url_link_display>Scheme</url_link_display>
    <tracks>
      <track>Scheme</track>
    </tracks>
    <timeslot>
      <slot_id>20878697-4899-45c6-b15f-7e0efc29c995</slot_id>
      <title>Deriving Pure, Functional One-Pass Operations for Processing Tail-Aligned Lists</title>
      <room>Conference Room 2</room>
      <date>2016/09/18</date>
      <start_time>17:30</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jason</first_name>
          <last_name>Hemann</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hemann.pl</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Friedman</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>Daniel P. Friedman is Professor of Computer Science at Indiana University. He is co-author of The Little Schemer, The Seasoned Schemer, The Reasoned Schemer, Scheme and the Art of Programming, and Essentials of Programming Languages, 3rd Edition, all published by MIT press.</bio>
          <homepage_url>https://www.cs.indiana.edu/~dfried/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/danielfriedman/5391c904-695b-421c-9fdf-3e24f5db7103/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Scheme</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>721ce973-1d5b-420c-9265-a161523f9b2a</slot_id>
      <title>miniAdapton: A Minimal Implementation of Incremental Computation in Scheme</title>
      <room>Conference Room 2</room>
      <date>2016/09/18</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dakota</first_name>
          <last_name>Fisher</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Hammer</last_name>
          <affiliation>University of Colorado, Boulder</affiliation>
          <bio>I’m interested in designing PL-based abstractions for settings in which humans and computers cooperate to create and process information. In particular, I’ve co-created abstractions for Incremental Computing (See Adapton for details) and for Secure Multiparty Computation (See Wysteria for details).
I am an assistant professor in the Department of Computer Science at University of Colorado Boulder. I am a co-director of the CU Programming Languages and Verification group (CUPLV). Before joining CU, I was a postdoc researcher working with Michael Hicks, Jeff Foster, David Van Horn and the PLUM group at the University of Maryland. As a PhD student, I was advised by Umut Acar.</bio>
          <homepage_url>http://matthewhammer.org</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/matthewahammer/0f8bb7ab-bcde-4522-beb0-8fb15d612e1b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>William E.</first_name>
          <last_name>Byrd</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://webyrd.net/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/williamebyrd/aa1e29fc-357f-4d95-a530-54e03b327c80/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Might</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>Associate Professor in Computing Science at the University of Utah. 
Visiting Associate Professor at the Harvard Medical School. 
Strategist in the Executive Office of the President at The White House.</bio>
          <homepage_url>http://matt.might.net/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/matthewmight/f660997f-e8d1-4f78-9a97-396d4da34536/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Scheme</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fbcefb0f-6e8b-448b-bf58-f6993b0b8502</subevent_id>
    <title>TyDe: Session Four</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/tyde-2016-papers</url>
    <url_link_display>Type-driven Development</url_link_display>
    <tracks>
      <track>Type-driven Development</track>
    </tracks>
    <timeslot>
      <slot_id>94bb80a5-bcad-4e55-bbab-e8f4ecef110f</slot_id>
      <title>Generic Lookup and Update for Infinitary Inductive-Recursive Types</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Larry</first_name>
          <last_name>Diehl</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tim</first_name>
          <last_name>Sheard</last_name>
          <affiliation>Portland State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cecs.pdx.edu/~sheard/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/timsheard/56d66b8c-49c6-4c81-8289-b100d778be31/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e0b7d41f-04e5-4c5d-ac67-c4d29e90523a</slot_id>
      <title>Programming with Monadic CSP-Style Processes in Dependent Type Theory</title>
      <room>Conference Room 1</room>
      <date>2016/09/18</date>
      <start_time>15:30</start_time>
      <end_time>16:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bashar</first_name>
          <last_name>Igried Deb Alkhawaldeh</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anton</first_name>
          <last_name>Setzer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Type-driven Development</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7fef94e6-0b05-4a85-89c4-6af3c394480e</subevent_id>
    <title>Scheme: Invited Talk</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/scheme-2016-papers</url>
    <url_link_display>Scheme</url_link_display>
    <tracks>
      <track>Scheme</track>
    </tracks>
    <timeslot>
      <slot_id>276c1945-f175-4a97-99b8-be01159ad7f2</slot_id>
      <title>R7RS update</title>
      <room>Conference Room 2</room>
      <date>2016/09/18</date>
      <start_time>14:00</start_time>
      <end_time>14:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>Scheme</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>daf16053-c463-451f-9a7e-ae551ad19e1c</slot_id>
      <title>GNU Guix: The Functional GNU/Linux Distro That’s a Scheme Library</title>
      <room>Conference Room 2</room>
      <date>2016/09/18</date>
      <start_time>14:20</start_time>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ludovic</first_name>
          <last_name>Courtès</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Scheme</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1489fc4d-8075-418c-85f0-636c8fb16723</subevent_id>
    <title>PLMW: 3</title>
    <subevent_type type="regular"/>
    <room>Conference Room 5</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/PLMW-ICFP-2016</url>
    <url_link_display>PLMW</url_link_display>
    <tracks>
      <track>PLMW</track>
    </tracks>
    <timeslot>
      <slot_id>65248d17-0ffd-44ab-9071-fd437a13934e</slot_id>
      <title>Introduction to Dependent Types</title>
      <room>Conference Room 5</room>
      <date>2016/09/18</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>Dependent type theory, which enriches simple type systems with types that can explicitly refer to programs, is a foundation for both mathematics and programming. Dependent types are the basis of proof assistants such as Agda, Coq, Idris, Twelf, and NuPRL, and various forms of dependency are making their way into more mainstream languages such as Haskell and OCaml. Dependent type theory has applications to program verification, computer-checked mathematical proofs, programming language metatheory and compiler verification, generic programming, and many other areas of programming and programming languages research. Some research projects in dependent types are very mathematical, studying enrichments of the basic systems of dependent type theory – for example, to better integrate effectful programming, or to better describe some mathematical concept that is to be formalized. Other projects are more engineering, such as building a large verified software artifact or mathematical proof using existing proof assistants. In this talk, I will show some small examples of dependently types programming, to give you a taste for what it is and can do, and survey some of the current research directions in the field.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dan</first_name>
          <last_name>Licata</last_name>
          <affiliation>Wesleyan University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dlicata.web.wesleyan.edu</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/danlicata/dbade80f-98b4-4022-a768-aa16c35b21d1/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PLMW</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8c07ca47-dc88-49fc-82b6-b8e1904a0b4f</slot_id>
      <title>Analyzing JavaScript Web Applications in the Wild (Mostly) Statically</title>
      <room>Conference Room 5</room>
      <date>2016/09/18</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>Analyzing real-world JavaScript web applications is a challenging task. On top of understanding the semantics of JavaScript, it requires modeling of web documents, platform objects, and interactions between them. Not only JavaScript itself but also its usage patterns are extremely dynamic. Most of web applications load JavaScript code dynamically, which makes pure static analysis approaches inapplicable.
In this talk, we present our attempts to analyze JavaScript web applications in the wild mostly statically using various approaches. From pure JavaScript programs to JavaScript web applications using platform-specific libraries, we explain technical challenges in analyzing each of them and how we built an open-source analysis framework for JavaScript, SAFE, that addresses the challenges incrementally.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sukyoung</first_name>
          <last_name>Ryu</last_name>
          <affiliation>KAIST</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plrg.kaist.ac.kr/ryu</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/sukyoungryu/3bdcd232-f3d4-4610-9953-30b513926e54/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PLMW</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d98db470-1c1d-4977-9dac-3a9febf251a8</subevent_id>
    <title>HOPE: Session 4 (Semantics)</title>
    <subevent_type type="regular"/>
    <room>Conference Room 3</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/hope-2016-papers</url>
    <url_link_display>HOPE</url_link_display>
    <tracks>
      <track>HOPE</track>
    </tracks>
    <timeslot>
      <slot_id>55ad7c21-b469-49b0-80f3-68f208a689c7</slot_id>
      <title>Functional models of full ground, and general, reference cells</title>
      <room>Conference Room 3</room>
      <date>2016/09/18</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>We present ongoing work developing a straightforward denotational semantics for reference cells of arbitrary types based on sets- with-structure and structure-preserving functions. We start with full ground references — which can refer to ground values and (recursively) ground references — where types denotes set-valued presheaves. By considering stores as mixed-variance set-valued functors (i.e., profunctors), we obtain two monads for full ground state which can interpret alloction, dereference, and mutation of full ground references, while validating the usual equations. We use this structure to give a denotational semantics to a monadic metalanguage with a special construct for effect masking similar to Haskell’s runST. Time permitting, we speculate how to extend this approach, using an appropriate recursive domain equation, to account for ML-like general reference cells.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ohad</first_name>
          <last_name>Kammar</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sean</first_name>
          <last_name>Moss</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>HOPE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6d63e06e-21c1-4bdd-bcc7-7273065dd402</subevent_id>
    <title>HOPE: Session 3 (Compilation)</title>
    <subevent_type type="regular"/>
    <room>Conference Room 3</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/hope-2016-papers</url>
    <url_link_display>HOPE</url_link_display>
    <tracks>
      <track>HOPE</track>
    </tracks>
    <timeslot>
      <slot_id>cc276e06-5c05-430d-a7be-6d2a3c81473a</slot_id>
      <title>Administrative normal form, continued: Sharing control in direct style</title>
      <room>Conference Room 3</room>
      <date>2016/09/18</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>Administrative normal form (ANF) promises to reap the benefits of continuation-passing style (CPS) while retaining the advantages of direct style. However, we believe ANF falls short of this ideal because it does not provide a satisfactory way to describe shared control flow, as CPS does naturally. We show how CPS itself can guide us in adding a control effect to ANF and taming it to regain purity, guaranteeing an efficient implementation. Interestingly, even though CPS is usually used for compiling call-by-value languages, our technique is independent of the evaluation strategy. In short, we propose that the known advantages of CPS can be achieved by extending ANF, or in general a direct-style representation. Does this mean that CPS is finally out? No: whatever the compiler’s chosen representation, we suspect CPS will reveal new insights about program manipulation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luke</first_name>
          <last_name>Maurer</last_name>
          <affiliation>University of Oregon, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Paul</first_name>
          <last_name>Downen</last_name>
          <affiliation>University of Oregon, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zena M.</first_name>
          <last_name>Ariola</last_name>
          <affiliation>University of Oregon, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Simon</first_name>
          <last_name>Peyton Jones</last_name>
          <affiliation>Microsoft Research, UK</affiliation>
          <bio>Simon Peyton Jones, MA, MBCS, CEng, graduated from Trinity College Cambridge in 1980. After two years in industry, he spent seven years as a lecturer at University College London, and nine years as a professor at Glasgow University, before moving to Microsoft Research (Cambridge) in 1998. His main research interest is in functional programming languages, their implementation, and their application. He has led a succession of research projects focused around the design and implementation of production-quality functional-language systems for both uniprocessors and parallel machines. He was a key contributor to the design of the now-standard functional language Haskell, and is the lead designer of the widely-used Glasgow Haskell Compiler (GHC). He has written two textbooks about the implementation of functional languages.
More generally, he is interested in language design, rich type systems, software component architectures, compiler technology, code generation, runtime systems, virtual machines, and garbage collection. He is particularly motivated by direct use of principled theory to practical language design and implementation – that’s one reason he loves functional programming so much.</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/simonpaytonjones/6128a22a-7036-4d52-90ac-2b1b5be66354/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HOPE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f9944ff5-4dfc-4dcc-94ef-23d7db154fbc</slot_id>
      <title>Type Directed Compilation of Row-typed Algebraic Effects</title>
      <room>Conference Room 3</room>
      <date>2016/09/18</date>
      <start_time>15:30</start_time>
      <end_time>16:00</end_time>
      <description>Algebraic effect handlers are recently gaining in popularity as a purely functional approach to modeling effects. As a restriction on general monads, algebraic effects come with various advantages: they can be freely composed, and there is a natural separation between their interface (as a set of operations) and their semantics (as a handler).
In this talk, I give an end-to-end overview of practical algebraic effects in the context of a compiled implementation in the Koka language. I’ll present a language design for algebraic effects, and show how algebraic effects subsume many control-flow constructs that are specialized in other languages, e.g. exceptions, state, iterators, async-await, etc. In particular, iterators and async-await are complex constructs that can lead to subtle interactions with other features and require complex compilation mechanisms. Being able to generalize over them using a single well-founded abstraction is a huge win.
Finally, I’ll briefly discuss an effective type inference algorithm based on extensible effect rows using scoped labels, a direct operational semantics. and an efficient compilation scheme to common runtime platforms (such as JavaScript, the JVM, or .NET) using a type directed selective CPS translation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daan</first_name>
          <last_name>Leijen</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>I am a member of the Research In Software Engineering (RISE) group and chair of the Programming Languages working group (PLX). Currently, I am interested in the design and application of strong type systems and declarative programming languages, like Haskell. In particular, I am interested in programming with Effect inference in the Koka project. Furthermore, I work on domain specific embedded languages, language design, and compiler technology.</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/daan/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/daanleijen/08223fe8-ae25-4bd2-8c16-27b5ab0cbd8c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HOPE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c6a2f262-239e-4ff4-bbe2-5c2230d08632</subevent_id>
    <title>HOPE: Session 2 (Verification)</title>
    <subevent_type type="regular"/>
    <room>Conference Room 3</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/hope-2016-papers</url>
    <url_link_display>HOPE</url_link_display>
    <tracks>
      <track>HOPE</track>
    </tracks>
    <timeslot>
      <slot_id>12846eaa-6f73-4a43-9d7f-bfbfb38d7b0b</slot_id>
      <title>Concurrent Data Structures Linked in Time</title>
      <room>Conference Room 3</room>
      <date>2016/09/18</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>Arguments about linearizability of a concurrent data structure are typically carried out by specifying the linearization points of the data structure’s procedures. Proofs that use such specifications are often cumbersome as the linearization points’ position in time can be dynamic, non-local and non-regional: it can depend on the interference, run-time values and events from the past, or even future, appear in procedures other than the one considered, and might be only determined after the considered procedure has terminated. In this paper we propose a new method, based on a Hoare-style logic, for reasoning about concurrent objects with such linearization points. We embrace the dynamic nature of linearization points, and encode it as part of the data structure’s auxiliary state, so that it can be dynamically modified in place by auxiliary code, as needed when some appropriate run-time event occurs. We name the idea linking-in-time, because it reduces temporal reasoning to spatial reasoning. For example, modifying a temporal position of a linearization point can be modeled similarly to a pointer update in a heap. We illustrate the method by verifying an intricate optimal snapshot algorithm due to Jayanti.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Germán</first_name>
          <last_name>Andrés Delbianco</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://delbian.co</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ilya</first_name>
          <last_name>Sergey</last_name>
          <affiliation>University College London, UK</affiliation>
          <bio>I am a lecturer (assistant professor) at University College London.
Prior to joining UCL, I was a postdoctoral researcher at IMDEA Software Institute (Madrid, Spain). I defended my PhD in 2012 in the DistriNet research group at the Department of Computer Sciences of KU Leuven (Belgium). Before that I received my MSc degree in Mathematics and Computer Science from Saint Petersburg State University (Russia) in 2008.
My research interests dwell in the area of the design and implementation of programming languages, including but not limited to program semantics, certified programming, concurrency and abstract interpretation. I am particularly interested in developing verification techniques and static analyses for higher-order and concurrent programs.</bio>
          <homepage_url>http://ilyasergey.net</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/ilyasergey/b2941c89-4843-4194-852a-81c8a30814fa/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Nanevski</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>My research is in the design and implementation of programming languages and logics for software verification. More specifically, I am interested in applying programming methodology to facilitate the construction of formal proofs in mathematics in general, and of program correctness in particular. My recent focus has been on designing methods for integrating programming with pointers, concurrency, and other important imperative features, into dependent type systems such as that of the proof assistant Coq. The goal of the integration is to leverage the proving power of Coq to obtain effective and scalable ways for reasoning about security and correctness of imperative programs.
I am also interested in all other aspects of formal mathematics and programming language theory and applications related to compilation, optimization, semantics, interactive theorem proving, program extraction, automated deduction, decision procedures, program analysis and model checking.</bio>
          <homepage_url>http://software.imdea.org/~aleks/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/aleksandarnanevski/a632b0b7-3813-4fc4-9622-b9341ae24ce1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anindya</first_name>
          <last_name>Banerjee</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>HOPE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1aeed92d-f427-44b0-82a7-e6dc75e636c6</slot_id>
      <title>Growing a Proof Assistant</title>
      <room>Conference Room 3</room>
      <date>2016/09/18</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>Sophisticated domain-specific and user-defined notation is widely used in formal models, but is poorly supported by proof assistants. This notation provides informal extensions to formal model that aid in communicating and reasoning about key ideas. Unfortunately, proof assistants do not allows users to conveniently define sophisticated notation. For instance, in modeling a programming language, we often define infix relations such as Γ ⊢ e : t and use BNF notation to specify the syntax of the language. In a proof assistant like Coq or Agda, users can easily define the notation for Γ ⊢ e : t , but to use BNF notation the user must use a preprocessing tool external to the proof assistant, which is cumbersome. To support sophisticated user-defined notation, we propose to use language extension as a fundamental part of the design of a proof assistant. We describe how to design a proof assistant that support safe, convenient, and sophisticated user-defined extensions, and show how language extension gives users the power to implement features of contemporary proof assistants.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>William J.</first_name>
          <last_name>Bowman</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>I am a fifth year Ph.D. student at Northeastern University where I study Computer Science (specifically, programming languages).
The promise of programming languages research has been to provide high-level languages in which programmers can easily write complex programs without worrying about speed or low-level machine details. I think we have failed. Languages that provide strong guarantees are bemoaned as too complicated, compilers ignore those high-level guarantees anyway, and the folklore persists that C is the only language useful for writing fast code.
I want to make programs easier to design, write, and understand. To that end, I work on verifying compilers. I am particularly interested in equivalence preserving (fully-abstract) compilers. I also dabble in dependent types and compiler design and implementation.</bio>
          <homepage_url>https://www.williamjbowman.com/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/williamjbowman/65b17dd6-298e-44ef-b32a-dc068c8c668b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HOPE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a7dd63f4-0976-4582-89b1-27965c34aff3</subevent_id>
    <title>HOPE: Session 1 (Effects)</title>
    <subevent_type type="regular"/>
    <room>Conference Room 3</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/hope-2016-papers</url>
    <url_link_display>HOPE</url_link_display>
    <tracks>
      <track>HOPE</track>
    </tracks>
    <timeslot>
      <slot_id>02aa6579-2c32-4b8b-8514-9ba055039664</slot_id>
      <title>Effects as Capabilities</title>
      <room>Conference Room 3</room>
      <date>2016/09/18</date>
      <start_time>10:45</start_time>
      <end_time>11:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fengyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>EPFL</affiliation>
          <bio>I’m a PhD student at EPFL. My interested areas are type systems, effect systems, programming languages, and various logics.</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/fengyunliu/7967ca32-789c-44f7-a256-c5eae78909c1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Stucki</last_name>
          <affiliation>EPFL, LAMP</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://github.com/nicolasstucki</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/nicolasstucki/4dfca9be-ecc5-4acb-a0bf-078dfb4abbf0/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sandro</first_name>
          <last_name>Stucki</last_name>
          <affiliation>EPFL</affiliation>
          <bio>Sandro is a PhD student at the Programming Methods Laboratory (LAMP) at EPFL, supervised by Martin Odersky. His research interests include type systems and type theory, the design and semantics of domain-specific languages and formal methods for modeling systems biology. He is participating in the ongoing effort to formalize Scala’s type system and likes to hack on type soundness proofs and other theories in Agda.</bio>
          <homepage_url>http://lamp.epfl.ch/~sstucki/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/sandrostucki/4e64a916-bd68-410c-a42c-3f34ec621ed7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Nada</first_name>
          <last_name>Amin</last_name>
          <affiliation>EPFL</affiliation>
          <bio>Nada Amin is a member of the Scala team at EPFL, where she studies type systems and hacks on programming languages. She has contributed to Clojure’s core.logic and Google’s Closure compiler. She’s loved helping others learn to program ever since tutoring SICP as an undergraduate lab assistant at MIT.</bio>
          <homepage_url>http://people.epfl.ch/nada.amin</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/nadaamin/90474e20-cab9-4520-944b-4ed731d34b58/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>Ecole Polytechnique Federale de Lausanne</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java. 
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as chairman of the Typesafe company.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/martinodersky/fc1dd696-d0d4-47cb-9d9a-bba012d98f9e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HOPE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>341bd7eb-0aca-4f07-840f-3028fb364495</slot_id>
      <title>A Logical Account of a Type-and-Effect System </title>
      <room>Conference Room 3</room>
      <date>2016/09/18</date>
      <start_time>11:15</start_time>
      <end_time>11:45</end_time>
      <description>Recently we have seen a renewed interest in programming languages that tame the complexity of state and concurrency through refined type systems with more fine-grained control over effects. In addition to simplifying reasoning and eliminating whole classes of bugs, statically controlling effects opens the door to advanced compiler optimisations, such as automatic parallelisation. The flip-side of this refined typing is that these languages often have to include trusted library code that violate the static typing discipline, in ways that are claimed to be unobservable to clients. In this paper we define a logical relation for a language with an ML-like type system refined with effect annotations that supports reasoning about contextual equivalence of potentially ill-typed terms. Using this relation we can formally justify such claims about breaking typing in unobservable ways. The logical relation also supports type-based optimizations, such as automatically parallelizing expressions whose effects are suitably disjoint. The logical relation is defined in Iris, a state-of-the-art higher-order separation logic. This allows us to fall back to a powerful program logic to prove semantic well-typedness in cases where the static typing discipline is too imprecise.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Morten</first_name>
          <last_name>Krogh-Jespersen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kasper</first_name>
          <last_name>Svendsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lars</first_name>
          <last_name>Birkedal</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~birke/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/larsbirkedal/c7844c55-6fb8-44e5-ad4d-45b69ae0dea8/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HOPE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e9f5d4c2-595d-478a-b3a8-984425f5bf0d</slot_id>
      <title>Simple Dependent Polymorphic I/O Effects</title>
      <room>Conference Room 3</room>
      <date>2016/09/18</date>
      <start_time>11:45</start_time>
      <end_time>12:15</end_time>
      <description>We give a short description of a very simple programming language, with a simple typing system that features explicit dependent and polymorphic I/O effects. This system having been inspired by type and effect systems allows types to express what I/O operations the typed program possibly performs. The aim of this system is not to provide a way to prove functional correctness of programs with I/O effects but rather demonstrate and argue that a simple type and effect system can allow us to get an upper bound on the I/O operations that a program performs. We present illustrative examples shedding light on possible uses of such a system. We briefly discuss possible directions for further work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Amin</first_name>
          <last_name>Timany</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bart</first_name>
          <last_name>Jacobs</last_name>
          <affiliation>iMinds - Distrinet, KU Leuven</affiliation>
          <bio>Assistant professor at the iMinds-DistriNet research group at the Department of Computer Science, KU Leuven - University of Leuven, Belgium</bio>
          <homepage_url>http://www.cs.kuleuven.be/~bartj/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/bartjacobs/03696ccf-6db6-4b61-8da5-b46289ec3d06/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HOPE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>66fc1b7d-592b-4f18-ba7e-fb8ae8ecea67</subevent_id>
    <title>HOPE: Welcome and Invited Talk</title>
    <subevent_type type="regular"/>
    <room>Conference Room 3</room>
    <date>2016/09/18</date>
    <url>http://conf.researchr.org/track/icfp-2016/hope-2016-papers</url>
    <url_link_display>HOPE</url_link_display>
    <tracks>
      <track>HOPE</track>
    </tracks>
    <timeslot>
      <slot_id>9a1f52cd-4817-47b2-aa99-7fa927ab79ba</slot_id>
      <title>Opening remarks</title>
      <room>Conference Room 3</room>
      <date>2016/09/18</date>
      <start_time>09:10</start_time>
      <end_time>09:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lars</first_name>
          <last_name>Birkedal</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~birke/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/larsbirkedal/c7844c55-6fb8-44e5-ad4d-45b69ae0dea8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aleksandar</first_name>
          <last_name>Nanevski</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>My research is in the design and implementation of programming languages and logics for software verification. More specifically, I am interested in applying programming methodology to facilitate the construction of formal proofs in mathematics in general, and of program correctness in particular. My recent focus has been on designing methods for integrating programming with pointers, concurrency, and other important imperative features, into dependent type systems such as that of the proof assistant Coq. The goal of the integration is to leverage the proving power of Coq to obtain effective and scalable ways for reasoning about security and correctness of imperative programs.
I am also interested in all other aspects of formal mathematics and programming language theory and applications related to compilation, optimization, semantics, interactive theorem proving, program extraction, automated deduction, decision procedures, program analysis and model checking.</bio>
          <homepage_url>http://software.imdea.org/~aleks/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/aleksandarnanevski/a632b0b7-3813-4fc4-9622-b9341ae24ce1/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HOPE</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fc21f0e1-ce0d-478f-a6a4-9455842f813d</slot_id>
      <title>Effective programming: bringing algebraic effects and handlers to OCaml</title>
      <room>Conference Room 3</room>
      <date>2016/09/18</date>
      <start_time>09:15</start_time>
      <end_time>10:15</end_time>
      <description>Algebraic effects were originally introduced to study the semantics of computational effects. With the addition of handlers they have become an exciting new programming construct for implementing such effects. Languages such as Eff have demonstrated that handlers can be used as a more composable alternative to monads for implementing effects in a pure language.
OCaml provides many standard effects, such as mutable state, built into the language. Those effects not built into the language, for example concurrency, are traditionally implemented using monads. The first part of this talk will describe work to implement native algebraic effects for OCaml. The original motivation for this work was to provide built-in support for concurrency in OCaml without tying the language to a particular concurrency implementation. However, algebraic effects support many interesting examples beyond concurrency.
As with exceptions, algebraic effects risk being performed in a context where they will not be handled. Type systems designed to track the side-effects of expressions have been around for many years, and seem eminently suitable for ensuring all algebraic effects are appropriately handled. Recent developments in languages such as Koka have begun to produce effect systems that are genuinely usable, but they have yet to breakthrough into a more mainstream language. The second part of this talk will describe work to integrate an effect system into OCaml whilst maintaining backwards compatibility. This system both prevents effects from going unhandled and turns OCaml into a pure functional language: successfully tracking the purity of functions through their types.
The talk will discuss the interesting questions and challenges that still remain before this work is ready for release into OCaml.
This is joint work with Stephen Dolan, Matija Pretnar and KC Sivaramakrishnan.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Leo</first_name>
          <last_name>White</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>HOPE</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6efb0257-9729-41a8-ae09-f781f78d9282</subevent_id>
    <title>HIW: The State of GHC</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/hiw-2016-papers</url>
    <url_link_display>HIW</url_link_display>
    <tracks>
      <track>HIW</track>
    </tracks>
    <timeslot>
      <slot_id>5a84ffe3-3091-452e-b743-7a3d75eaead2</slot_id>
      <title>Contributing to GHC</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>09:45</start_time>
      <end_time>10:15</end_time>
      <description>GHC has seen a remarkable amount of change in the past five years. This can be seen both in the features that have been implemented, as well as structure of the community which implemented them. While our technical infrastructure has been adapting with the adoption of Phabricator, better automation, and improved continuous integration, the collaborative and social mechanisms which have served our developer community well in the past may be showing their age.
To remain sustainable, we need to ensure that the scale of GHC’s developer community keeps up with growth in both the compiler itself and its user community. In this session we will discuss some of the sticking points in GHC’s development process, especially with respect to on-boarding of new contributors and treatment of external proposals.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ben</first_name>
          <last_name>Gamari</last_name>
          <affiliation>Well-Typed LLP</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>886b4d1c-be3b-4ae4-8b8c-471219c47a82</slot_id>
      <title>The State of GHC</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>09:15</start_time>
      <end_time>09:45</end_time>
      <description>As has been the case since the very first Haskell Implementor’s Workshop, Simon Peyton Jones gives a status update on the development GHC, the most widely used Haskell compiler in existence today.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Peyton Jones</last_name>
          <affiliation>Microsoft Research, UK</affiliation>
          <bio>Simon Peyton Jones, MA, MBCS, CEng, graduated from Trinity College Cambridge in 1980. After two years in industry, he spent seven years as a lecturer at University College London, and nine years as a professor at Glasgow University, before moving to Microsoft Research (Cambridge) in 1998. His main research interest is in functional programming languages, their implementation, and their application. He has led a succession of research projects focused around the design and implementation of production-quality functional-language systems for both uniprocessors and parallel machines. He was a key contributor to the design of the now-standard functional language Haskell, and is the lead designer of the widely-used Glasgow Haskell Compiler (GHC). He has written two textbooks about the implementation of functional languages.
More generally, he is interested in language design, rich type systems, software component architectures, compiler technology, code generation, runtime systems, virtual machines, and garbage collection. He is particularly motivated by direct use of principled theory to practical language design and implementation – that’s one reason he loves functional programming so much.</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/simonpaytonjones/6128a22a-7036-4d52-90ac-2b1b5be66354/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ec32aa1d-9f12-491f-868f-a002ddbbc9aa</subevent_id>
    <title>Erlang: Erlang in Robotics &amp; Erlang Latest News</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/erlang-2016-papers</url>
    <url_link_display>Erlang</url_link_display>
    <tracks>
      <track>Erlang</track>
    </tracks>
    <timeslot>
      <slot_id>7a92dca4-2e30-45ba-a7d6-5da35b0fa262</slot_id>
      <title>Towards Reliable and Scalable Robot Communication</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>16:40</start_time>
      <end_time>17:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andreea</first_name>
          <last_name>Lutac</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Natalia</first_name>
          <last_name>Chechina</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>Natalia Chechina is a Research Fellow at the University of Glasgow. She received a PhD degree from Heriot-Watt University, UK in 2011. She then worked as a Research Associate at the University of Glasgow in the RELEASE project (2011-2015 A High-Level Paradigm for Reliable Large-Scale Server Software) sponsored by an EU FP7 STREP (287510).</bio>
          <homepage_url>http://dcs.gla.ac.uk/~natalia/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/nataliachechina/6898c8ee-e453-4770-9e3b-eb76fa0c595e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gerardo</first_name>
          <last_name>Aragon-Camarasa</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Phil</first_name>
          <last_name>Trinder</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~trinder/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b94366dd-b20d-4290-a10a-d9f55e6595d7</slot_id>
      <title>Erlang latest news</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>17:05</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e7642650-8434-48cf-90fb-c5eec161c550</slot_id>
      <title>Farewell &amp; Closing</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>17:30</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b05ad9eb-caaa-4fd1-a71e-3c36850b5f7e</subevent_id>
    <title>Erlang: Invited Keynote Talk</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/erlang-2016-papers</url>
    <url_link_display>Erlang</url_link_display>
    <tracks>
      <track>Erlang</track>
    </tracks>
    <timeslot>
      <slot_id>3509da54-eab2-4f5f-9ec0-2ce339ad0bae</slot_id>
      <title>Opening &amp; Welcome</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>09:15</start_time>
      <end_time>09:25</end_time>
      <description>undefined</description>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d7a933b9-c676-4ae2-a035-359bb4488545</slot_id>
      <title>Keynote: Solutions to distributed system problems, 'Akka', actors.</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>09:25</start_time>
      <end_time>10:15</end_time>
      <description>Nowadays, microservice architectures are commonly used for building distributed systems. Despite their advantages, there are some common problems that arise. In this talk, I present my experience solving some of these problems by using actors, and more specifically, the Akka toolkit.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>María del Mar</first_name>
          <last_name>Rubio González</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/mariadelmarrubiogonzalez/1016c0bd-9d8c-4bb3-9f0d-26fbb2b4946b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>60cf08df-b842-49cd-8cb7-c04763c3ab72</subevent_id>
    <title>HIW: Backends for GHC</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/hiw-2016-papers</url>
    <url_link_display>HIW</url_link_display>
    <tracks>
      <track>HIW</track>
    </tracks>
    <timeslot>
      <slot_id>266d021d-e1eb-4c20-b778-ee0c0b584d0f</slot_id>
      <title>Remote GHCi</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>15:20</start_time>
      <end_time>15:45</end_time>
      <description>Haxl users at Facebook do a lot of development and testing inside GHCi. In fact, we’ve built a customized version of GHCi that runs code in our Haxl monad by default instead of the IO monad, and has a handful of extra commands to support common workflows needed by our developers. This is a pretty smooth setup: right inside GHCi we can test the production code against real data, and interact with all of the services that our production systems talk to, while having a nice interactive edit/compile/test cycle.
However, one thing is missed by many developers, especially those coming from other languages: easy access to a stack trace when debugging.
This talk will tell the story of how we implemented always-on stack traces in GHCi, which are now available in GHC 8.0.1. The implementation involves splitting out the interpreter from GHCi into a separate process, so that the interpreted code can run in profiling mode (where stack traces are available), while the compiler continues to run at full speed on the unprofiled runtime. GHC communicates with the interpreter using binary messages over a pipe.
Remote GHCi has a number of other benefits, including fixing the long-standing annoyance that to compile TH code with -prof you had to build it twice. It will also be useful for using TH when cross-compiling, and has a lot of overlap with a similar mechanism already implemented in GHCJS; indeed we hope to converge on a single implementation in the future.
(more background for the talk in this blog post: http://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html)</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Marlow</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Simon Marlow is a Software Engineer on Facebook’s Site Integrity Infrastructure team in London. He is working on Haxl, a Haskell-based domain-specific language that is used by the teams fighting spam and malware. Simon is a co-author of the Glasgow Haskell Compiler, author of the book “Parallel and Concurrent Programming in Haskell”, and has a string of research publications in functional programming, language design, compilers, and language implementation.</bio>
          <homepage_url>http://community.haskell.org/~simonmar/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/simonmarlow/d6f3111f-a2c1-4f7f-af4b-7744c18ea27e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3e40bc5b-3176-4b75-a345-9bdfbffd4d1e</slot_id>
      <title>GHCVM - A JVM Backend for GHC</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>15:45</start_time>
      <end_time>16:10</end_time>
      <description>GHCVM is a compiler that translates GHC 7.10.3’s Haskell to Java bytecodes, using a slightly modified version of GHC [1]. It aims to reduce the entry barrier for companies who wish to deploy Haskell but are bound to the JVM. The code generator and runtime system were carefully modeled after GHC, translating the primitive concepts to Java equivalents.
I will discuss the progress so far and highlight the key design decisions that were made to preserve GHC’s semantics on the JVM. Additionally, I will discuss future directions of GHCVM including an intermediate representation for simplifying bytecode compilation, support for an external interpreter and Template Haskell, and utilizing the recent developments in the JVM for performance boosts.
[1] The GHC API was used initially, but the rigidity of the API forced me to inline the entire GHC frontend into the GHCVM codebase.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rahul</first_name>
          <last_name>Muttineni</last_name>
          <affiliation>TypeLead</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ce8585c8-c211-4aca-8076-13b67d7c46d6</subevent_id>
    <title>ML: Web</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/mlfamilyworkshop-2016-papers</url>
    <url_link_display>ML</url_link_display>
    <tracks>
      <track>ML</track>
    </tracks>
    <timeslot>
      <slot_id>185747f0-92b8-4894-b29b-9d308de336e8</slot_id>
      <title>Extracting from F* to C: a progress report</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>11:00</start_time>
      <end_time>11:25</end_time>
      <description>F* is a language in the tradition of ML equipped with dependent types, monadic effects, refinement types and a weakest precondition calculus. Together, these features enable the F* programmer to prove functional correctness using a combination of automation via SMT solving and manual program proofs. 
In the context of the greater Everest project, we are using F* to prove, build and deploy miTLS, a verified, efficient implementation of the Transport Layer Security (TLS) 1.3 protocol. 
This extended abstract presents our work in progress. We are currently focusing our efforts on proving the memory safety and functional correctness of Elliptic Curve Cryptography (ECC) primitives, and on extracting this code to C. ECC primitives are a good candidate: they are modeled after the reference implementations in C. Therefore, they only exercise an imperative, first-order subset of F* that lends itself well to an efficient extraction to C.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Protzenko</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jonathan.protzenko.fr</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/jonathanprotzenko/203c9e40-1cbf-40d3-b59f-da4a4c305361/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Karthikeyan</first_name>
          <last_name>Bhargavan</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jean-Karim</first_name>
          <last_name>Zinzindohoue</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Abhishek</first_name>
          <last_name>Anand</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Cedric</first_name>
          <last_name>Fournet</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/fournet/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Bryan</first_name>
          <last_name>Parno</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Aseem</first_name>
          <last_name>Rastogi</last_name>
          <affiliation>Microsoft Research India</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/aseemr/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/aseemrastogi/60be692f-f2e1-4eef-ac4a-85f7accdba8e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Nikhil</first_name>
          <last_name>Swamy</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>I’m a Researcher in the RiSE group at MSR Redmond. My work covers various topics including type systems, program logics, functional programming, program verification and interactive theorem proving. I often think about how to use these techniques to build provably secure programs, including web applications, web browsers, crypto protocol implementations, and low-level systems code.</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/nswamy/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/nikhilswamy/077cd684-6d6a-44a9-ad24-e69061c7128e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3a0ae2fe-207c-41d2-bc30-fecc8fa7312f</slot_id>
      <title>WebAssembly: high speed at low cost for everyone</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>10:35</start_time>
      <end_time>11:00</end_time>
      <description>WebAssembly is a new language- and platform-independent binary code format bringing native-code performance to the web. We present its design and report our experience with specifying its semantics via a reference interpreter written in OCaml, that currently serves as a proxy for a future formal specification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Rossberg</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rossberg/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/andreasrossberg/dd081052-55a0-4210-8ea6-3f2e1bd20d04/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>07b857b3-9b48-4bde-b193-15e30cc2bec4</subevent_id>
    <title>Erlang: Experience report presentations </title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/erlang-2016-papers</url>
    <url_link_display>Erlang</url_link_display>
    <tracks>
      <track>Erlang</track>
    </tracks>
    <timeslot>
      <slot_id>437afbfa-535e-4a70-a36d-98b686ae1583</slot_id>
      <title>Making everybody comfortable with Erlang: a SCADA system for thermal control</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>12:10</start_time>
      <end_time>12:35</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Laura M.</first_name>
          <last_name>Castro</last_name>
          <affiliation>University of  A Coruña</affiliation>
          <bio>I was born in Madrid, Spain in 1980 and moved to Galicia, located in the north west coast of the country, when I was in my teens. I went to high school in Santiago de Compostela and attended college in A Coru&amp;ntilde;a, where I now live and work. I have also lived for short periods of time in the US (Houston, Texas) and Sweden (G&amp;ouml;teborg).
I am a postdoc researcher and assistant lecturer at the University of A Coru&amp;ntilde;a, where I have been teaching since 2005. At the moment, I am in charge of teaching Software Architecture and Software Validation to 3rd and 4th year undegrads.
I also perform research in the areas of software testing (automated, model and property-based testing), applied to software in general, and distributed, concurrent, functional systems in particular. I am a member of the MADS (Models and Applications of Distributed Systems) research group.</bio>
          <homepage_url>http://www.madsgroup.org/staff/laura</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/lauramcastro/30de4e05-c6c4-41d1-824b-84aeaffec0f2/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>J. Daniel</first_name>
          <last_name>Fernandez</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Carlos</first_name>
          <last_name>Lopez Pampin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b08e6e5f-09ab-47b2-b452-ba04010ee069</slot_id>
      <title>Observing the consistency of distributed systems</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Deepthi</first_name>
          <last_name>Devaki Akkoorath</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Viktória</first_name>
          <last_name>Fördős</last_name>
          <affiliation>Erlang Solutions Ltd.</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/viktoriafordos/a479b518-1019-4964-bdd6-52dfff98c989/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Annette</first_name>
          <last_name>Bieniusa</last_name>
          <affiliation>Technischen Universität Kaiserslautern</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-user.rhrk.uni-kl.de/~bieniusa/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a81f8868-3173-4467-a140-f184262ceae4</subevent_id>
    <title>CUFP: Talks 4</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/cufp-2016-papers</url>
    <url_link_display>CUFP</url_link_display>
    <tracks>
      <track>CUFP</track>
    </tracks>
    <timeslot>
      <slot_id>2a18425a-ae0c-4aa3-b662-d0a17466ddfb</slot_id>
      <title>Composable Caching in Swift</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>15:20</start_time>
      <end_time>15:45</end_time>
      <description>Consider what it means to be a cache. You need to be able to (1) associate a key with a value and (2) get some value given a key if such a value exists. That’s basically it. Caches tend to appear in layers. In a CPU, memory reads check L1, then L2, then L3, then RAM. When we want to load an image, we first check RAM, then disk, and finally network. 
In a mobile app, if you don’t nail your cache code, your users will suffer. Excessive networking causes both battery and data-plan drain. We can help ensure a clean correct implementation by combining caches. Given two caches A and B, A on-top-of B means first check A, fallthrough to B, then write back to A. Now we can define a monoid for caches. Monoids imply easy composition. Easy composition means reasoning about our code becomes easy.
Such an abstraction isn’t possible to express both statically and generically in languages like Objective-C and Java, but we can with Swift’s strong type system. The caching library Carlos provides the foundation upon which we can build prefetching and other useful transformations. In our app, adopting such a system simplified our codebase: Caches became reusable legos. But the complexity doesn’t just all go away, it’s just hidden. With an abstraction so nice, it’s tempting to think of the actual caches and cache glue as black-boxes. One problem we ran into was a reference cycle that led to large bitmaps leaking and phones running out of memory. It’s important to actually think about the implementation details in detail, since these are your building blocks for the rest of the system. When your building blocks are stable, your building is stable.
Caching and prefetching are necessary for mobile apps. In this talk, I will explain how to think about caches as monoids, how a monoidal caching system can simplify our jobs as software engineers, and what real-world problems we ran into when putting such a system into production.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Brandon</first_name>
          <last_name>Kase</last_name>
          <affiliation>Pinterest</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9b7994af-8c43-41fc-91bb-780dd29138f3</slot_id>
      <title>Guix: Scheme as a uniform OS admin and deployment interface</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>15:45</start_time>
      <end_time>16:10</end_time>
      <description>GNU Guix is a tool implementing the functional package management paradigm pioneered by Nix. It is rooted in the free software world where it has a growing user and contributor community. Guix and the Guix System Distribution (GuixSD) put an emphasis on providing a unified Scheme environment to deal with package management, container and virtual machine provisioning, operating system deployment, configuration, services, and associated activities.
In this talk I will describe the techniques we use to achieve this unified interface, with the intent to blur the user/developer distinction, and our early experience. The oft-discussed advantages of embedding domain-specific languages (DSLs) have allowed us to develop tools and a programming environment that many envy. Our use of Scheme covers domains traditionally associated with C, Perl, or Python: “build scripts”, system initialization code, service management, Linux containers, and more. Pervasive use of Scheme leads to a “multi-tier” programming environment; I will describe our staging techniques, implemented as mere Scheme syntax extensions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ludovic</first_name>
          <last_name>Courtès</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ef87e305-2078-4bab-b67c-cdb64472974f</subevent_id>
    <title>ML: Classes</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/mlfamilyworkshop-2016-papers</url>
    <url_link_display>ML</url_link_display>
    <tracks>
      <track>ML</track>
    </tracks>
    <timeslot>
      <slot_id>03098c08-8df5-4803-975f-7fac0c1aedc6</slot_id>
      <title>Classes for the Masses</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>15:20</start_time>
      <end_time>15:45</end_time>
      <description>Type classes are an immensely popular and productive feature of Haskell. They have since been adopted in, and adapted to, numerous other languages, including theorem provers. This talk will show that type classes have a natural and efficient representation in .NET. This paves the way for the extension of F# and other .NET languages with Haskell style type classes. The representation is type preserving and promises easy and safe cross-language inter-operation. We are currently, and rapidly, extending the open source C# compiler and language service, Roslyn, with support for type classes but intend to do the same for F# once that work has been completed.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Claudio</first_name>
          <last_name>Russo</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Windsor</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Don</first_name>
          <last_name>Syme</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/dsyme/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Rupert</first_name>
          <last_name>Horlick</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>James</first_name>
          <last_name>Clarke</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b7947284-d7a3-4c34-8e42-d1f792158dd2</slot_id>
      <title>Close Encounters of the Higher Kind - Emulating Constructor Classes in Standard ML</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>15:45</start_time>
      <end_time>16:10</end_time>
      <description>We implement a library for encoding constructor classes in Standard ML, including elaboration from minimal definitions, and automatic instantiation of superclasses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yutaka</first_name>
          <last_name>Nagashima</last_name>
          <affiliation>Data61, Australia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Liam</first_name>
          <last_name>O'Connor</last_name>
          <affiliation>UNSW, Australia</affiliation>
          <bio>Liam is a PhD student at UNSW Australia working on Trustworthy Systems projects with Data61 at CSIRO (formerly known as NICTA). His PhD work focuses on the use of linear typed languages to provide easy-to-reason-about semantics for formal verification of operating system components. More broadly, his research interests include automated proof and reasoning, particularly in the context of dependently typed programming languages, type inference, static analysis, and concurrency.</bio>
          <homepage_url>http://liamoc.net</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/liamoconnor/62bc9dba-ffaf-41b7-94db-85d112d608ea/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2923bb77-c523-4a2d-acc4-f8a2f7128adb</subevent_id>
    <title>ML: Invited Talk</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/mlfamilyworkshop-2016-papers</url>
    <url_link_display>ML</url_link_display>
    <tracks>
      <track>ML</track>
    </tracks>
    <timeslot>
      <slot_id>47373a03-4b46-4af1-833b-3523807efb50</slot_id>
      <title>Making Reactive Programs Function</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>09:15</start_time>
      <end_time>10:15</end_time>
      <description>The ML family of programming languages is best known as a family of functional programming languages, but most ML-family languages also offer support for effects such as control operators and state. Indeed, they usually support full first-class general references, which can contain values of any type, including higher types. Concretely, programmers may store functions that can modify the heap, within the heap itself.
Since higher-order imperative programs are often much more difficult to understand than programs using either higher-order or imperative features alone, programmers are encouraged to stick to the functional fragment much as possible. However, one place where higher-order state is used quite heavily in practice is in interactive programs, like graphical user interfaces. These reactive systems are typically implemented in an aggressively higher-order stateful style, with each mutable component storing a set of callbacks to invoke whenever a particular event happens.
In this talk, I will describe a recent line of work on structuring these kinds of programs, based on the idea of using a Curry-Howard proof term correspondence with temporal logic as a type system for reactive programs. One of the surprises of this line of work is how many of the standard implementation techniques for reactive programs turn out to realize fundamental logical primitives. This opens the door to reactive programming models which retain both the simple reasoning principles of functional programming, and the efficient implementation strategies known to working programmers.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Neelakantan R.</first_name>
          <last_name>Krishnaswami</last_name>
          <affiliation>University of Birmingham, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mpi-sws.org/~neelk/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/neelakantankrishnaswami/61a5e7f5-2edd-4b98-ad13-3295b01601ca/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dba4a4c9-4075-4c74-8e5d-b8de871eb61c</slot_id>
      <title>Welcome</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>09:10</start_time>
      <end_time>09:15</end_time>
      <description>undefined</description>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>39f319fd-d1e3-409d-8ad8-9d31d8c48569</subevent_id>
    <title>ML: Effects</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/mlfamilyworkshop-2016-papers</url>
    <url_link_display>ML</url_link_display>
    <tracks>
      <track>ML</track>
    </tracks>
    <timeslot>
      <slot_id>bf6a6a1d-5e98-4e13-859a-a925a553f290</slot_id>
      <title>Compiling Links Effect Handlers to the OCaml Backend</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>Algebraic effects and handlers provide a modular abstraction for modeling and controlling computational effects. We present a compiler for the experimental language Links with effect handlers. Our compiler interfaces with the Multicore OCaml backend to take advantage of OCaml’s implementation of efficient handlers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Hillerström</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>PhD student at the University of Edinburgh, Scotland, UK</bio>
          <homepage_url>http://www.homepages.inf.ed.ac.uk/s1467124</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/danielhillerstrom/22512b81-b136-4451-bcdd-f3d2fbc0210a/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Lindley</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/slindley/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/samlindley/32dd34f2-c14b-412f-811e-449bbff76c7f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>KC</first_name>
          <last_name>Sivaramakrishnan</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>I am a Post-doctoral Research Associate under the OCaml Labs initiative at the University of Cambridge Computer Lab, an 1851 Research Fellow and a Research Fellow at Darwin College, Cambridge. I am also a member of the Network and Operating Systems group.
I am interested in the design and implementation of concurrent functional programming languages targeting scalable platforms such as many-core processors and compute clouds. My research spans programming models, compilers, static analysis, schedulers, threading systems, and memory management.
Before coming to Cambridge, I was a graduate student at Purdue University where I obtained an MS and a PhD degree in Computer Science under the supervision of the wonderful Prof. Suresh Jagannathan. At Purdue, I led the MultiMLton and Quelea projects. Before that, I obtained my BEng degree in Computer Science and Engineering from Anna University, India.</bio>
          <homepage_url>http://kcsrk.info/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/kcsivaramakrishnan/8e3c8515-42d7-499a-9b77-9d8918acb314/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>db2ff1ec-21a3-482f-a292-fdbe894c4c46</slot_id>
      <title>Eff Directly in OCaml</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>We present the embedding of the language Eff into OCaml, using the library of delimited continuations or the OCaml-effects branch. The embedding is systematic, lightweight, performant and supports even higher-order, `dynamic’ effects with their polymorphism. OCaml thus may be regarded as another implementation of Eff, broadening the scope and appeal of that language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oleg</first_name>
          <last_name>Kiselyov</last_name>
          <affiliation>Tohoku University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://okmij.org/ftp/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/olegkiselyov/575daa05-880d-4f2f-b085-acbece1d264e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>KC</first_name>
          <last_name>Sivaramakrishnan</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>I am a Post-doctoral Research Associate under the OCaml Labs initiative at the University of Cambridge Computer Lab, an 1851 Research Fellow and a Research Fellow at Darwin College, Cambridge. I am also a member of the Network and Operating Systems group.
I am interested in the design and implementation of concurrent functional programming languages targeting scalable platforms such as many-core processors and compute clouds. My research spans programming models, compilers, static analysis, schedulers, threading systems, and memory management.
Before coming to Cambridge, I was a graduate student at Purdue University where I obtained an MS and a PhD degree in Computer Science under the supervision of the wonderful Prof. Suresh Jagannathan. At Purdue, I led the MultiMLton and Quelea projects. Before that, I obtained my BEng degree in Computer Science and Engineering from Anna University, India.</bio>
          <homepage_url>http://kcsrk.info/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/kcsivaramakrishnan/8e3c8515-42d7-499a-9b77-9d8918acb314/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1c7991c3-4f9d-4fee-b0b0-43794e12cb77</subevent_id>
    <title>Erlang: Poster presentations</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/erlang-2016-papers</url>
    <url_link_display>Erlang</url_link_display>
    <tracks>
      <track>Erlang</track>
    </tracks>
    <timeslot>
      <slot_id>261700a2-ca16-4347-a5fa-08fd6beb5097</slot_id>
      <title>Towards Semi-Automatic Data-Type Translation for Parallelism in Erlang</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>15:45</start_time>
      <end_time>16:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Adam</first_name>
          <last_name>Barwell</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Brown</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Hammond</last_name>
          <affiliation>University of St. Andrews, UK</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>David</first_name>
          <last_name>Castro</last_name>
          <affiliation>University of St. Andrews, UK</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4dc7a611-664a-4a4a-b631-39610768a610</slot_id>
      <title>Automatic generation of UML sequence diagrams from test counterexamples</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>15:20</start_time>
      <end_time>15:45</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Carballa</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laura M.</first_name>
          <last_name>Castro</last_name>
          <affiliation>University of  A Coruña</affiliation>
          <bio>I was born in Madrid, Spain in 1980 and moved to Galicia, located in the north west coast of the country, when I was in my teens. I went to high school in Santiago de Compostela and attended college in A Coru&amp;ntilde;a, where I now live and work. I have also lived for short periods of time in the US (Houston, Texas) and Sweden (G&amp;ouml;teborg).
I am a postdoc researcher and assistant lecturer at the University of A Coru&amp;ntilde;a, where I have been teaching since 2005. At the moment, I am in charge of teaching Software Architecture and Software Validation to 3rd and 4th year undegrads.
I also perform research in the areas of software testing (automated, model and property-based testing), applied to software in general, and distributed, concurrent, functional systems in particular. I am a member of the MADS (Models and Applications of Distributed Systems) research group.</bio>
          <homepage_url>http://www.madsgroup.org/staff/laura</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/lauramcastro/30de4e05-c6c4-41d1-824b-84aeaffec0f2/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>08046565-60f9-4c03-b9e6-45e267131bac</subevent_id>
    <title>CUFP: Talks 2</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/cufp-2016-papers</url>
    <url_link_display>CUFP</url_link_display>
    <tracks>
      <track>CUFP</track>
    </tracks>
    <timeslot>
      <slot_id>2989677d-b51f-4c36-8750-be6f9d62c292</slot_id>
      <title>Chaos testing with F# and Azure</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>Some of the biggest growing pains we’ve experienced with our microservice architecture at Jet is in preparing for system outages. I’ll start with an overview of the benefits of choosing F# specifically, and functional programming in general, as well as Azure, for a chaos program. I’ll follow up with a discussion of why your team needs to implement a chaos testing program, and finish with showing off our methods and code in depth.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rachel</first_name>
          <last_name>Reese</last_name>
          <affiliation>Jet.com</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>92b7023d-ef5f-43ba-a0ff-73e07532f33d</slot_id>
      <title>Building a web application with continuation monads</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>12:10</start_time>
      <end_time>12:35</end_time>
      <description>Niconico is a video sharing and a live streaming platform operated by Dwango. Dwango uses Scala widely for foundation systems such as an account system, a billing system and an event bus for inter-services. In this talk, we will introduce how to build web applications by using continuation monads. This approach is mainly used in the Niconico account system.
The Niconico account system has the following requirements: 
 
 Various requests 
 Various user registration leads 
 OAuth logins (Google, Facebook, Twitter, etc.) 
 Multi-factor authentication 
 Various responses 
 HTML Pages (in Japanese, English and Chinese) 
 JSON and XML 
 Redirects 
 Various filterings 
 CSRF check 
 Add CORS headers 
 User tracking 

The Niconico account system is developed with Play framework which is one of the most popular web framework in Scala. Play framework has component technologies for building web applications. But the composition functionality of Play framework is insufficient to our requirements. Therefore, we decided to use components of continuation monads instead of the standard technique of Play framework. We believe that our approach can also be applied to other languages, because a web framework often has similar nested structures such as Java Servlet, Python WSGI, and so on.
This talk will be a detailed explanation of the topic presented at ScalaMatsuri 2016.
Our prototype implementation has been published on GitHub.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Seitaro</first_name>
          <last_name>Yuki</last_name>
          <affiliation>Dwango</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4ad830a6-f089-491a-b3b9-bc482ae4cc8a</subevent_id>
    <title>HIW: Trees and Lightning Talks</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/hiw-2016-papers</url>
    <url_link_display>HIW</url_link_display>
    <tracks>
      <track>HIW</track>
    </tracks>
    <timeslot>
      <slot_id>78150ee4-c7c8-4f44-8286-e62e7b32b1b9</slot_id>
      <title>Lightning talks</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>17:05</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aa7a5efd-aef1-4381-9358-74242df1c0cd</slot_id>
      <title>Trees That Grow</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>16:40</start_time>
      <end_time>17:05</end_time>
      <description>Algebraic datatypes and pattern matching in Haskell lay a fertile ground to conveniently define and process abstract syntax trees (ASTs). However, in Haskell, trees often cannot grow: once a datatype is defined and compiled, it cannot be extended. Extensions to a datatype mainly appear as new fields to its existing data constructors, and/or new data constructors.
At the center of any metaprogramming system stand tall trees representing the abstract syntax of object terms. Metaprograms processing these trees often do so by decorating nodes with additional information. This additional information may appear as new fields to the existing data constructors, and/or new data constructors. Common practice is either post hoc, to define a new separate datatype representing the output decorated trees; or pre hoc, to use the same large datatype to represent both the non-decorated input and the decorated output trees. Both methods are often ad hoc; the former leads to duplication, and the latter forces the input trees to carry an unnecessary set of information making them inconvenient to work with.
In this talk, I introduce an encoding of datatypes that allows them to be extended in a post hoc manner, yet still argueably keeping them convenient to work with. It is done as a part of the the Summer of Haskell project titled “Native Metaprogramming in Haskell”, where we considered unifying the two most popular representations of Haskell’s syntax: the small and convenient AST in the popular library Haskell-Src-Exts (HSE), and the large decorated AST used inside GHC’s front-end (HsSyn).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shayan</first_name>
          <last_name>Najd</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Peyton Jones</last_name>
          <affiliation>Microsoft Research, UK</affiliation>
          <bio>Simon Peyton Jones, MA, MBCS, CEng, graduated from Trinity College Cambridge in 1980. After two years in industry, he spent seven years as a lecturer at University College London, and nine years as a professor at Glasgow University, before moving to Microsoft Research (Cambridge) in 1998. His main research interest is in functional programming languages, their implementation, and their application. He has led a succession of research projects focused around the design and implementation of production-quality functional-language systems for both uniprocessors and parallel machines. He was a key contributor to the design of the now-standard functional language Haskell, and is the lead designer of the widely-used Glasgow Haskell Compiler (GHC). He has written two textbooks about the implementation of functional languages.
More generally, he is interested in language design, rich type systems, software component architectures, compiler technology, code generation, runtime systems, virtual machines, and garbage collection. He is particularly motivated by direct use of principled theory to practical language design and implementation – that’s one reason he loves functional programming so much.</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/simonpaytonjones/6128a22a-7036-4d52-90ac-2b1b5be66354/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jacques</first_name>
          <last_name>Carette</last_name>
          <affiliation>McMaster University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cas.mcmaster.ca/~carette</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/jacquescarette/cbb97dd2-6942-4eec-8a4a-bed915929a88/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>581a5b3a-d600-4b7d-8b0b-8c235f7adb4b</subevent_id>
    <title>ML: Future</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/mlfamilyworkshop-2016-papers</url>
    <url_link_display>ML</url_link_display>
    <tracks>
      <track>ML</track>
    </tracks>
    <timeslot>
      <slot_id>712f0447-49e3-43a7-bb21-8e257a1d5c88</slot_id>
      <title>Malfunctional Programming</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>16:40</start_time>
      <end_time>16:55</end_time>
      <description>Malfunction is an untyped program representation intended as a compilation target for functional languages, consisting of a thin wrapper around OCaml’s Lambda intermediate representation. 
Compilers targeting Malfunction convert programs to a simple s-expression-based syntax with clear semantics, which is then compiled to native code using OCaml’s back-end, enjoying both the optimisations of OCaml’s new flambda pass, and its battle-tested runtime and garbage collector.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Dolan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>837e2135-f8f1-4d2d-b3e6-c5e69e3c64f2</slot_id>
      <title>Ambiguous pattern variables</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>16:55</start_time>
      <end_time>17:20</end_time>
      <description>The or-pattern (p | q) matches a value v if either p or q match v. It may happen that both p and q match certain values, but that they don’t bind their variables at the same places. OCaml specifies that the left pattern p then takes precedence, but users intuitively expect an angelic behavior, making the ``best’’ choice. Subtle bugs arise from this mismatch. When are (p | q) and (q | p) observably different? 
To correctly answer this question we had to go back to pattern matrices, the primary technique to compile patterns and analyze them for exhaustivity, redundant clauses, etc. There is a generational gap: pattern matching was actively studied when most ML languages were first implemented, but many of today’s students and practitioners trust our elders to maintain and improve them. Read on for your decadely fix of pattern matching theory!</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriel</first_name>
          <last_name>Scherer</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gallium.inria.fr/~scherer/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/gabrielscherer/12b45ebf-b3bf-4d6e-a8eb-fb44283475f9/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Luc</first_name>
          <last_name>Maranget</last_name>
          <affiliation>INRIA Rocquencourt</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Réfis</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ce50558f-d4e8-4461-8166-220eea89984c</slot_id>
      <title>Typed Embedding of Relational Language in OCaml</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>17:20</start_time>
      <end_time>17:35</end_time>
      <description>We present an implementation of relational programming language miniKanren as a set of combinators and syntax extension for OCaml. The key feature of our approach is polymorphic unification, which can be used to unify data structures of almost arbitrary types. In addition we provide a useful generic programming pattern to systematically develop relational specifications in a typed manner, and address the problem of relational and functional code integration.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dmitri</first_name>
          <last_name>Kosarev</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dmitri</first_name>
          <last_name>Boulytchev</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>65a21700-614f-4a9e-ae70-6ce156df860c</subevent_id>
    <title>ML: Implementation</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/mlfamilyworkshop-2016-papers</url>
    <url_link_display>ML</url_link_display>
    <tracks>
      <track>ML</track>
    </tracks>
    <timeslot>
      <slot_id>64da3d47-1b98-41a2-a5f2-c87390b42ded</slot_id>
      <title>Compiling with Continuations and LLVM</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>This paper describes a new LLVM-based backend for the Parallel ML compiler (part of the Manticore system). This backend is novel in that it supports heap-allocated first-class continuations (a first for LLVM), which, in turn enables language features, such as callcc, lightweight concurrency mechanisms, and PML’s parallelism features.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kavon</first_name>
          <last_name>Farvardin</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://kavon.farvard.in</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/kavonfarvardin/e1385ba6-42de-4482-ba49-de87451e6cae/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>John</first_name>
          <last_name>Reppy</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>John Reppy has been exploring issues in language design and implementation since the late 1980’s, with a focus on higher-order, typed, functional languages. He is the inventor of Concurrent ML (CML), co-inventor of the Moby programming language, and has made major contributions to the Standard ML of New Jersey system. He is also the co-editor of the the Standard ML Basis Library specification. His current research focus is on the design and implementation of parallel-programming languages as part of the Manticore and Diderot projects.
He received his PhD from Cornell University in 1992 and worked at Bell Laboratories, Murray Hill for eleven years. He is currently a professor of Computer Science and a Senior Fellow of the Computation Institute at the University of Chicago. From August 2011 through August 2013, he served as a Program Director at the National Science Foundation where he helped start the Exploiting Parallelism and Scalability program (XPS).</bio>
          <homepage_url>http://people.cs.uchicago.edu/~jhr/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/johnreppy/7c9e332e-ee11-4f40-82ee-8864028ba80b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cad500e3-2b6f-49cb-8a43-771261d78261</slot_id>
      <title>SML# with Natural Join</title>
      <room>Conference Room 1</room>
      <date>2016/09/22</date>
      <start_time>12:10</start_time>
      <end_time>12:25</end_time>
      <description>This paper reports on the extension of SML# with natural join operator commonly used in database query. The extension is based on the database typing of Ohori and Buneman and an HM(X)-style constraint polymorphic typing. Based on this typing and type inference algorithm, the seamless SQL integration of SML# is extended with natural join. The extended SML# is available as a version 3.1.0-trial_join.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tomohiro</first_name>
          <last_name>Sasaki</last_name>
          <affiliation>Tohoku University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Katsuhiro</first_name>
          <last_name>Ueno</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/katsuhiroueno/26e33bd1-fd8a-4eab-9ad6-ff2ad45cbe8e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Ohori</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>ML</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b99747b1-c39a-4eaf-96f9-9bc93e47d80a</subevent_id>
    <title>HIW: Types and Effects</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/hiw-2016-papers</url>
    <url_link_display>HIW</url_link_display>
    <tracks>
      <track>HIW</track>
    </tracks>
    <timeslot>
      <slot_id>08c4df64-d817-4b2e-addb-8345967b9c3d</slot_id>
      <title>Automatically Escaping Monads</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>12:10</start_time>
      <end_time>12:35</end_time>
      <description>New Haskell programmers often find themselves “trapped in a monad”. Given a computation of type ‘IO a’, there is no way to get the ‘a’ value “out” of the computation. One can use the monadic ‘bind’ operator to create a new computation based on the old one, but this can lead to an awkward style of programming. Haskell is really two distinct sub languages, where the pure sub language is used to compose computations in the monadic sub-language. When effects need to be added to previously pure code we also need to undertake a big refactoring effort, converting ‘let’ to ‘do’, and ‘map’ to ‘mapM’ and so on.
In this talk I’ll present a practical implementation of a coeffect system that lets us get the ‘a’ out. Given a suspended computation M of type ‘IO a’, ‘run M’ evaluates it, releasing its effect into the context, and producing the value of type ‘a’. Conversely, given a term N of type ‘a’ which would perform an IO effect when evaluated, ‘box N’ suspends its evaluation, returning a value of type ‘IO a’. This idea has been described previously, by both Filinski [1] who named the operators ‘reflect’ and ‘reify’, as well as Pfenning and Davies [2] in the context of lax modal logic.
Although the theory works out, manually inserting ‘run’ and ‘box’ casts into a program is even more annoying than converting ‘let’-expressions to ‘do’-expressions when effects need to be added to pure code. Luckily, there is a way to automatically insert these casts during type checking, so we can write code in a style that assumes implicit effects (like in ML), but with types as nice as in Haskell. This system has recently been implemented in DDC [3] as an extension to Dunfield and Krishnaswami’s bidirectional type checking algorithm [4]. Automatically inserting run and box casts works surprisingly well, and also supports DDC’s approach to type safe freezing, where mutable objects can be converted to immutable ones, without unsafe hacks like ‘unsafeFreezeArray’.
[1] Representing Monads Andrzej Filinski Principles of Programming Languages, 2004.
[2] A Judgmental Reconstruction of Modal Logic Frank Pfenning and Rowan Davies Mathematical Structures in Computer Science, 2000.
[3] The Disciplined Disciple Compiler https://github.com/DDCSF/ddc
[4] Complete and Easy Bidirectional Typechecking for Higher-Ranked Polymorphism. Joshua Dunfield and Neelakantan Krishnaswami International Conference on Functional Programming, 2013.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ben</first_name>
          <last_name>Lippmeier</last_name>
          <affiliation>University of New South Wales</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://benl.ouroborus.net/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/benlippmeier/9bb00e8c-9048-4fec-847b-6d7743f8fa62/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4aae4050-05b6-47e0-9eed-efc30573eef4</slot_id>
      <title>A Dependent Haskell Triptych</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>This talk will include three examples, compilable today, of dependently typed programming in Haskell: 
 
 A finely-typed database access library whereby the requirements placed on the schema of the database can be inferred from the client code. This means that the database and the access code can be updated independently of one another, as long as the schema meets the inferred requirements. 
 A datatype design pattern allowing for both row and column extensibility. This example makes critical use of both an injective type family and a higher-rank kind. 
 A translation of Idris’s algebraic effects library to Haskell, allowing for client code to use several effects (such as state, failure, or I/O) together in a composable fashion without monad transformers or manual lifting. 

The goal of this talk is not to explain all of the details of any of these examples, nor is it to advertise any release-ready software expected to be used in your next project. Instead, this talk is intended to showcase the kinds of problems dependent types in Haskell might solve and a sneak peek at some solutions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Richard</first_name>
          <last_name>Eisenberg</last_name>
          <affiliation>Bryn Mawr College</affiliation>
          <bio>Assistant Professor at Bryn Mawr College. I completed my PhD in 2016 at University of Pennsylvania working under Stephanie Weirich; my dissertation topic was the integration of dependent types into the Haskell programming language. I am a regular contributor to the Glasgow Haskell Compiler (GHC).</bio>
          <homepage_url>http://cs.brynmawr.edu/~rae</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/richardeisenberg/2d03068d-412f-453b-ac98-b41b80ec03ca/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f88ad9b7-ab86-4147-93c8-08edde9bdfb8</subevent_id>
    <title>HIW: Pluggability and Modularity</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/hiw-2016-papers</url>
    <url_link_display>HIW</url_link_display>
    <tracks>
      <track>HIW</track>
    </tracks>
    <timeslot>
      <slot_id>6b6deab9-21fa-4695-988d-ad57cc2e10fe</slot_id>
      <title>Backpack to Work: Towards Backpack in Practice</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>10:35</start_time>
      <end_time>11:00</end_time>
      <description>The universal organizing principle for large software systems in programming languages today is the package, the unit by which reusable code may be versioned and distributed. However, most package systems provide only a weak form of modularity, where packages depend directly on other packages. Backpack breaks new ground by arguing mixin packages can be a good fit for package-level modularity. Unfortunately, Backpack as was described in POPL’14 cannot be easily implemented for most existing languages today (including Haskell), because it tightly couples the compiler with the package manager. In this talk, I describe an evolution of the Backpack design which respects the division between package manager and compiler. This is not a paper design: it is principally motivated by our (ongoing) efforts to implement Backpack in GHC and the Cabal package system, which we hope to land for GHC 8.2.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Edward Z.</first_name>
          <last_name>Yang</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>I am a fourth year PhD student at Stanford advised by David Mazi&amp;egrave;res and John Mitchell. I am a proud member of the Secure Computer Systems group. I’m interested in applying operating system mechanisms (hardware isolation, dynamic resource limits) to the design and construction of programming languages, and vice versa (type systems, formal verification, information flow control). I’m a big fan of Haskell, a non-strict purely functional language.r.</bio>
          <homepage_url>http://ezyang.com</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/edwardzyang/870a9dc5-eac9-4b9d-8453-ea916df981b5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9140cf7f-ba55-44e9-9ffe-07c2f538f722</slot_id>
      <title>More powerful GHC Plugins</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>11:00</start_time>
      <end_time>11:25</end_time>
      <description>GHC provides a plugin interface for writing type checker plugins and for some time also frontend plugins. The plugin interface, however could be much more powerful.
With the addition of a few new hooks, more powerful plugins can be build that can control the compilation pipeline and other parts of ghc.
This talk will outline what is currently possible, and what new hooks the author has in development, as well as issues arising from using the plugin interface.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Moritz</first_name>
          <last_name>Angermann</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dad2e675-cc28-4584-9187-4f8d9ec75162</subevent_id>
    <title>CUFP: Talks 1</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/cufp-2016-papers</url>
    <url_link_display>CUFP</url_link_display>
    <tracks>
      <track>CUFP</track>
    </tracks>
    <timeslot>
      <slot_id>9269bfc4-a9fb-492c-bd1f-143b3912af69</slot_id>
      <title>Developing a fast and durable pub/sub message bus</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>11:00</start_time>
      <end_time>11:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Will</first_name>
          <last_name>Sewell</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d2cd2e14-4ac4-48eb-95f2-e1b00d664f16</slot_id>
      <title>Immutable Infrastructure Deployment with Haskell</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>10:35</start_time>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Nick</first_name>
          <last_name>Hibberd</last_name>
          <affiliation>Ambiata</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>977f6d99-ea2f-4621-af68-b222c39a730b</subevent_id>
    <title>CUFP: Talks 5</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/cufp-2016-papers</url>
    <url_link_display>CUFP</url_link_display>
    <tracks>
      <track>CUFP</track>
    </tracks>
    <timeslot>
      <slot_id>64768e30-3dec-4f1c-b322-1bfa35437353</slot_id>
      <title>Closing remarks</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>17:55</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Katie</first_name>
          <last_name>Ots</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Katie Ots is a Software Engineer at Facebook London, where she works on Haskell tools for spam fighters. Katie co-founded the Lambda Ladies group for women in functional programming.</bio>
          <homepage_url>http://www.codemiller.com/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/katieots/1781445a-910f-478d-835d-9355eea720cf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alex</first_name>
          <last_name>Lang</last_name>
          <affiliation>Tsuru Capital</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.linkedin.com/in/alex-lang-309a6953</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c1fb1d3a-30f5-4966-9f48-8a2981c6c0d7</slot_id>
      <title>Baby steps to unikernels in production</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>16:40</start_time>
      <end_time>17:05</end_time>
      <description>Unikernels are an exciting new take on applications design and deployment. OCaml has been quietly forging ahead in the area with libraries like Mirage, whereby we can generate apps that operate at such a low level we don’t even need operating systems on the backend anymore (removing 15 million lines of memory-unsafe code) - while at the same time, maintaining more reliable software with less effort through lightweight type-checked code sharing between server, browser clients, &amp;amp; native mobile apps.
While much theory and effort has been put into building the basis of Mirage, deploying unikernels into production (whether on public clouds or private servers) remains a very artisanal experience. In the talk we’ll look at how the properties of Mirage unikernel enable us to rethink large sections of the app development lifecycle (apps that are MBs in size and boot in 50 milliseconds!), and also look at a case study of what it takes to move said unikernels to production with reliable testing, deployment, monitoring, and debug tooling.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sean</first_name>
          <last_name>Grove</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.riseos.com</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f8d3407e-56b5-4a43-b797-16d670728861</slot_id>
      <title>Hope is a Monad</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>17:05</start_time>
      <end_time>17:55</end_time>
      <description>What, in the end, distinguishes the functional programmer from the OO developer? Much effort is spent on arguing how FP is more efficient. More significant, however, is that functional programmers produce different models from their OO and relational counterparts, which enable more powerful software architecture. The talk traces this observation through 13 years of functional programming applied in industrial projects, in a variety of languages. I’ll touch on projects in stage lighting (&amp;quot;“stage lighting has algebraic structure”“), financial derivatives (”“market data is compositional”“), semiconductor manufacturing (”“hope is a monad”“, ”“scheduling is an arrow”“), social pedagogy (”“the GUI is a function”&amp;quot;), and others, as time permits.
While a number of lessons from these experiences may seem obvious, they were hard-won: 
 
 purely functional is better 
 look for compositionality 
 monads can be found in unexpected places 

(Not among them: Static types are better.)</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Sperber</last_name>
          <affiliation>Active Group GmbH</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://deinprogramm.de/sperber/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/michaelsperber/e0008500-aa96-40e3-87f9-afe454474878/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>db6941bd-65ad-43f7-abb9-17a6a618f28b</subevent_id>
    <title>Erlang: Scalability and Distribution</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/erlang-2016-papers</url>
    <url_link_display>Erlang</url_link_display>
    <tracks>
      <track>Erlang</track>
    </tracks>
    <timeslot>
      <slot_id>65cf0d7d-57ef-4249-aa37-0a077dad1ab6</slot_id>
      <title> CRDTs for the Configuration of Distributed Erlang Systems</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>11:00</start_time>
      <end_time>11:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Viktória</first_name>
          <last_name>Fördős</last_name>
          <affiliation>Erlang Solutions Ltd.</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/viktoriafordos/a479b518-1019-4964-bdd6-52dfff98c989/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Cesarini</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8ea2e5ba-e706-4244-866c-11394db812b3</slot_id>
      <title>A Scalable Reliable Instant Messenger using the SD Erlang Libraries</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>10:35</start_time>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Natalia</first_name>
          <last_name>Chechina</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>Natalia Chechina is a Research Fellow at the University of Glasgow. She received a PhD degree from Heriot-Watt University, UK in 2011. She then worked as a Research Associate at the University of Glasgow in the RELEASE project (2011-2015 A High-Level Paradigm for Reliable Large-Scale Server Software) sponsored by an EU FP7 STREP (287510).</bio>
          <homepage_url>http://dcs.gla.ac.uk/~natalia/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/nataliachechina/6898c8ee-e453-4770-9e3b-eb76fa0c595e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mario Moro</first_name>
          <last_name>Hernandez</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Phil</first_name>
          <last_name>Trinder</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~trinder/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fcd87ce6-cfbb-4811-98a9-073363742752</subevent_id>
    <title>HIW: The Engineering of GHC</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/hiw-2016-papers</url>
    <url_link_display>HIW</url_link_display>
    <tracks>
      <track>HIW</track>
    </tracks>
    <timeslot>
      <slot_id>ed9f464a-cffa-481e-9acf-6d12842a44e5</slot_id>
      <title>Pita: Tools for making GHC fast again</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>The accumulation of new language additions, standard library interfaces, and compiler features had led to noticably longer compile times in GHC in recent years. Joachim Breitner’s Gipeda is a great diagnostic tool for analysing particular commits. In our effort to make GHC fast again, we were in need of diagnostic tools to analyze compound compile times across periods spanning from weeks to years.
With the Performance Indicator Tracking Application, Pita, we introduce a diagnostic tool for visualizing changes in GHC’s performance characteristics over the course of development. Based on the same dataset used by Gipeda, Pita offers side-by-side comparisons across time and multiple tests. Using Pita, we are able to quickly identify correlations and patterns that trigger compile time speed bumps, allowing us to narrow down years of development to a small set of regressing commits.
This talk provides an introduction to Pita. Using hands-on examples we show how to chase down speed bumps in past commits. Finally, we discuss the state of our effort in improving GHC’s performance, discussing some of the common themes that we have found in the course of the work and sharing some best practices for GHC contributors to minimize the impact of their changes on compiler performance.
Using Pita we have already reduced compiler allocations by 8% on average across nofib. We are hoping that with further work we will ultimately be able to bring compilation times back to pre-7.6 magnitudes in the coming year. We invite the community to help us realize this goal.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ben</first_name>
          <last_name>Gamari</last_name>
          <affiliation>Well-Typed LLP</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f4acba33-143f-4e64-9803-7624a3fe1513</slot_id>
      <title>GHC Determinism</title>
      <room>Conference Room 1</room>
      <date>2016/09/24</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>Compilation with GHC was non-deterministic prior to version 8.0.2. Compiling with the same flags, sources, and environment could produce incompatible binary objects.
Non-deterministic compilation causes several problems. Non-deterministic interface files result in slower incremental builds because of unnecessary recompilation. Distributed build systems, such as Buck or Bazel, cannot reliably cache non-deterministic object files, negating the primary benefit of distributed compilation. Non-determinism results in unstable symbol names, making code hot-swapping difficult. Non-deterministic output forces packagers of binary distributions such as Debian to waste resources recompiling after a trivial change and also makes it impossible to verify if a binary was built from the given code. 
During the past couple of months I tested GHC for non-determinism on itself and Stackage, developed a non-determinism test suite, and systematically audited GHC’s internals to ensure that compilation is deterministic in GHC 8.0.2. In this talk I will discuss the causes of non-determinism, how I addressed them, and how we can keep GHC deterministic going forward.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bartosz</first_name>
          <last_name>Nitka</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>HIW</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>be962cd6-8b20-442d-8528-b8c8e0d460ba</subevent_id>
    <title>Erlang: Tools</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/erlang-2016-papers</url>
    <url_link_display>Erlang</url_link_display>
    <tracks>
      <track>Erlang</track>
    </tracks>
    <timeslot>
      <slot_id>0221d914-3ce7-468f-9821-29f031b86949</slot_id>
      <title>The Nifty Way to Call Hell from Heaven </title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Löscher</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kostis</first_name>
          <last_name>Sagonas</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>32f4e17b-5b46-480b-8348-68947dd88717</slot_id>
      <title>Profiling Actor Utilization and Communication in Akka</title>
      <room>Conference Room 2</room>
      <date>2016/09/23</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andrea</first_name>
          <last_name>Rosà</last_name>
          <affiliation>Università della Svizzera italiana</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.inf.usi.ch/phd/rosaa</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/andrearosa/56bfbe88-343d-473c-b65b-a085469b0cae/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lydia Y.</first_name>
          <last_name>Chen</last_name>
          <affiliation>IBM Research Lab Zurich</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Walter</first_name>
          <last_name>Binder</last_name>
          <affiliation>University of Lugano</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Erlang</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>469e8549-f29c-479b-9e36-1c75369b18d1</subevent_id>
    <title>CUFP: Keynote</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/cufp-2016-papers</url>
    <url_link_display>CUFP</url_link_display>
    <tracks>
      <track>CUFP</track>
    </tracks>
    <timeslot>
      <slot_id>a655ffda-f4a7-49de-8f3a-99049fb191eb</slot_id>
      <title>Keynote</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>09:20</start_time>
      <end_time>10:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaron</first_name>
          <last_name>Minsky</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/yaronminsky/4b00b8d8-8a54-452b-b11c-e7c269d64554/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b0036353-d26c-4c65-a32f-c8f974d8b23d</slot_id>
      <title>Opening remarks</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>09:15</start_time>
      <end_time>09:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Katie</first_name>
          <last_name>Ots</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Katie Ots is a Software Engineer at Facebook London, where she works on Haskell tools for spam fighters. Katie co-founded the Lambda Ladies group for women in functional programming.</bio>
          <homepage_url>http://www.codemiller.com/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/katieots/1781445a-910f-478d-835d-9355eea720cf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alex</first_name>
          <last_name>Lang</last_name>
          <affiliation>Tsuru Capital</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.linkedin.com/in/alex-lang-309a6953</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>36c7eef5-073b-49d1-a1ba-d11d35b9ded2</subevent_id>
    <title>CUFP: Talks 3</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/cufp-2016-papers</url>
    <url_link_display>CUFP</url_link_display>
    <tracks>
      <track>CUFP</track>
    </tracks>
    <timeslot>
      <slot_id>1855f77f-f147-441d-9146-bd12d11cb236</slot_id>
      <title>The Highs and Lows of Optimising DSLs</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>So, you’ve written a DSL, it’s a work of art! It so perfectly models the problem at hand that even a trained house cat could generate business value. You just have one problem, your interpreter runs 100x slower than a shell script launching JVMs in a loop.
Domain specific languages (DSLs) are able to offer the abstraction benefits of a high-level language, while when compiled, competing with low-level languages on performance. Because DSLs have a much smaller problem area, many specialised optimisations can be performed which are not feasible for a general purpose language.
In this talk, we will explain a number of optimisations which are useful for DSLs, and show our solutions to the practical issues we faced when implementing them in our query language, Icicle.
Icicle is a query language for processing large amounts of time-series data. Its type system enforces that queries require only a single pass over the data, and that multiple queries over the same data can be fused together. By using a combination of high level optimisations such as partial evaluation and common subexpression elimination, and low level optimisations such as parsing code which is specialised for the given input, our queries are faster than the equivalent hand-written C code.
From this talk, the audience will learn how the focused point of view that DSLs provide can be useful in performance critical systems, as well as a number of concrete techniques for optimising their own DSLs.
Target
Anyone who is interested in domain specific languages (DSLs), embedded or external, and wants to know how to make them beat the pants off hand written C/C++.
The techniques presented are applicable to DSLs written in any language, although a familiarity with Haskell syntax would be a plus.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jacob</first_name>
          <last_name>Stanley</last_name>
          <affiliation>Ambiata</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7633291d-f0df-4161-bb5c-cc9849b88882</slot_id>
      <title>Creating an approachable Haskell-like DSL</title>
      <room>Noh Theater</room>
      <date>2016/09/24</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>At Fugue, we built our own statically typed DSL, Ludwig, to configure cloud infrastructure in a declarative way.
The DSL relates to the Haskell language in two ways. First, the language’s compiler and toolchain are written in Haskell. Secondly, the DSL is heavily inspired by Haskell. It also borrows interesting features from other languages, such as extensible records with row-type polymorphism and an intuitive YAML-like syntax.
Having a Haskell-inspired functional language certainly made it possible to build powerful abstractions. However, this often come at a price. Many of our prospective users in DevOps have little or no experience in functional programming. This means that they frequently have a hard time understanding how these languages work.
This is a problem for adoption: we want people to look at our examples and immediately feel at home. This talk will focus on how we are trying to achieve that. We will talk about how we constructed the different aspects of the DSL (syntax, type system…) in such a way that anyone who is comfortable editing YAML can pick up the language easily.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jasper</first_name>
          <last_name>Van der Jeugt</last_name>
          <affiliation>Fugue</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CUFP</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bc21c4f5-53b3-44ab-ab74-b57c73035b66</subevent_id>
    <title>FHPC: DIscussion</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/FHPC-2016-papers</url>
    <url_link_display>FHPC</url_link_display>
    <tracks>
      <track>FHPC</track>
    </tracks>
    <timeslot>
      <slot_id>696e45d0-5e3e-4c35-b362-6e9104bd7ac8</slot_id>
      <title>Discussion</title>
      <room>Conference Room 2</room>
      <date>2016/09/22</date>
      <start_time>17:05</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>FHPC</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f8f01fda-d1b8-4a17-a882-4f5217e4a53b</subevent_id>
    <title>FHPC: Graph Processing</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/FHPC-2016-papers</url>
    <url_link_display>FHPC</url_link_display>
    <tracks>
      <track>FHPC</track>
    </tracks>
    <timeslot>
      <slot_id>f06752cd-7946-4561-aafa-2737fd668c42</slot_id>
      <title>s6raph: Vertex-Centric Graph Processing Framework with Functional Interface</title>
      <room>Conference Room 2</room>
      <date>2016/09/22</date>
      <start_time>16:40</start_time>
      <end_time>17:05</end_time>
      <description>Parallel processing of big graph-shaped data still presents many challenges. Several approaches have appeared recently, and a strong trend focusing on understanding graph computation as iterative vertex-centric computations has emerged. There have been several systems in the vertex-centric approach, for example Pregel, Giraph, GraphLab and PowerGraph. Though programs developed in these systems run efficiently in parallel, writing vertex-programs usually results in code with poor readability, that is full of side effects and control statements unrelated to the algorithm.
In this paper we introduce “s6raph”, a new vertex-centric graph processing framework with a functional interface that allows the user to write clear and concise functions. The user can choose one of several default behaviours provided for most common graph algorithms. We discuss the design of the functional interface and introduce our prototype implementation in Erlang.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Onofre</first_name>
          <last_name>Coll Ruiz</last_name>
          <affiliation>Kochi University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kiminori</first_name>
          <last_name>Matsuzaki</last_name>
          <affiliation>Kochi University of Technology, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.info.kochi-tech.ac.jp/~kmatsu/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shigeyuki</first_name>
          <last_name>Sato</last_name>
          <affiliation>Kochi University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>FHPC</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4f0e1445-dc90-46d5-838b-749a579b5648</subevent_id>
    <title>FHPC: Invited Talk</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/FHPC-2016-papers</url>
    <url_link_display>FHPC</url_link_display>
    <tracks>
      <track>FHPC</track>
    </tracks>
    <timeslot>
      <slot_id>b9b582bf-9edb-4511-bae0-302636efa2e3</slot_id>
      <title>From Identification of Parallelizability to Derivation of Parallelizable Codes</title>
      <room>Conference Room 2</room>
      <date>2016/09/22</date>
      <start_time>09:15</start_time>
      <end_time>10:15</end_time>
      <description>Although now parallel computing is very common, current parallel programming methods tend to be domain-specific (specializing in certain program patterns such as nested loops) and/or manual (programmers need to specify independent tasks). This situation poses a serious difficulty in developing efficient parallel programs. We often need to manually transform codes written in usual programming patterns to ones in a parallelizable form. We hope to have a solid foundation to streamline this transformation. This talk first reviews necessity of a method of systematically deriving parallelizable codes and then introduces an ongoing work on extending lambda calculus for the purpose. The distinguished feature of the new calculus is a special construct that enable evaluation with incomplete information, which is useful to express important parallel computation patterns such as reductions (aggregations). We then investigate derivations of parallelizable codes as transformations on the calculus.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Akimasa</first_name>
          <last_name>Morihata</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.graco.c.u-tokyo.ac.jp/labs/morihata/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/akimasamorihata/c0883451-c2d1-42da-8e5d-d6e6699b8c8e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>FHPC</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c4e61371-e870-4466-a142-18fcf4b4f36b</subevent_id>
    <title>FHPC: GPUs</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/FHPC-2016-papers</url>
    <url_link_display>FHPC</url_link_display>
    <tracks>
      <track>FHPC</track>
    </tracks>
    <timeslot>
      <slot_id>06f1fccc-758d-4cd6-89a0-0ce23c89e905</slot_id>
      <title>APL on GPUs: A TAIL from the Past, Scribbled in Futhark</title>
      <room>Conference Room 2</room>
      <date>2016/09/22</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>This paper demonstrates translation schemes by which programs written in a functional subset of APL can be compiled to code that is run efficiently on general purpose graphical processing units (GPGPUs). Furthermore, the generated programs can be straightforwardly interoperated with mainstream programming environments, such as Python, for example for purposes of visualization and user interaction. Finally, empirical evaluation shows that the GPGPU translation achieves speedups up to hundreds of times faster than sequential C compiled code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Troels</first_name>
          <last_name>Henriksen</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>I try to make functional programs to really, really fast. It’s not easy.</bio>
          <homepage_url>http://sigkill.dk</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/troelshenriksen/cc6f9601-4f83-467d-8063-85f9b13b9f6f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Dybdal</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Henrik</first_name>
          <last_name>Urms</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anna Sofie</first_name>
          <last_name>Kiehn</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Gavin</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Hjalte</first_name>
          <last_name>Abelskov</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Martin</first_name>
          <last_name>Elsman</last_name>
          <affiliation>Department of Computer Science, University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.elsman.com</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/martinelsman/1158f40b-68de-48a0-939e-89f98f6b4f18/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Cosmin</first_name>
          <last_name>Oancea</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>FHPC</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3f7a72ea-4451-49a9-91a9-87129ca827f2</slot_id>
      <title>Low-Level Functional GPU Programming for Parallel Algorithms</title>
      <room>Conference Room 2</room>
      <date>2016/09/22</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>We present a Functional Compute Language (FCL) for low-level GPU programming. FCL is functional in style, which allows for easy composition of program fragments and thus easy prototyping and a high degree of code reuse. In contrast with projects such as Futhark, Accelerate, Harlan, Nessie and Delite, the intention is not to develop a language providing fully automatic optimizations, but instead to provide a platform that supports absolute control of the GPU computation and memory hierarchies. The developer is thus required to have an intimate knowledge of the target platform, as is also required when using CUDA/OpenCL directly.
FCL is heavily inspired by Obsidian. However, instead of relying on a multi-staged meta-programming approach for kernel generation using Haskell as meta-language, FCL is completely selfcontained, and we intend it to be suitable as an intermediate language for data-parallel languages, including data-parallel parts of high-level array languages, such as R, Matlab, and APL.
We present a type-system and a dynamic semantics suitable for understanding the performance characteristics of both FCL and Obsidian-style programs. Our aim is that FCL will be useful as a platform for developing new parallel algorithms, as well as a targetlanguage for various code-generators targeting GPU hardware.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Dybdal</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Elsman</last_name>
          <affiliation>Department of Computer Science, University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.elsman.com</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/martinelsman/1158f40b-68de-48a0-939e-89f98f6b4f18/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bo Joel</first_name>
          <last_name>Svensson</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~joels/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Mary</first_name>
          <last_name>Sheeran</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/maryshe/53b14c10-657f-4faf-94fa-a8b70086863d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>FHPC</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a33a00b3-9f98-4a46-a0f7-6e92a0748ddb</subevent_id>
    <title>FHPC: Domain Specific Languages</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/FHPC-2016-papers</url>
    <url_link_display>FHPC</url_link_display>
    <tracks>
      <track>FHPC</track>
    </tracks>
    <timeslot>
      <slot_id>8f0bbd93-2855-4f06-9599-4b243e7208af</slot_id>
      <title>Using Fusion to Enable Late Design Decisions for Pipelined Computations</title>
      <room>Conference Room 2</room>
      <date>2016/09/22</date>
      <start_time>11:00</start_time>
      <end_time>11:25</end_time>
      <description>We present an embedded language in Haskell for programming pipelined computations. The language is a combination of Feldspar (a functional language for array computations) and a new implementation of Ziria (a language for describing streaming computations originally designed for programming software defined radio). The resulting language makes heavy use of fusion: as in Feldspar, computations over arrays are fused to eliminate intermediate arrays, but Ziria processes can also be fused, eliminating the message passing between them, which in turn can give rise to more fusion at the Feldspar level. The result is a language in which we can first describe pipelined computations at a very fine-grained level, and only afterwards map computations onto the details of a specific parallel architecture, where the fusion helps us to generate efficient code. This flexible design method enables late design decisions cheaply, which in turn can lead to more efficient produced code. In the paper, we present two examples of pipelined computations in our language that can be run on Adapteva’s Epiphany many-core coprocessor and on other back-ends.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mate</first_name>
          <last_name>Karacsony</last_name>
          <affiliation>Eötvös Loránd University</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/matekaracsony/ab71646f-ddbb-479e-8722-bc0633047d35/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Koen</first_name>
          <last_name>Claessen</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~koen/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/koenclaessen/893f5363-3c94-4f98-a251-06c021537878/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>FHPC</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9abc221d-98e8-4301-a591-74b5036a8699</slot_id>
      <title>Icicle: Write Once, Run Once</title>
      <room>Conference Room 2</room>
      <date>2016/09/22</date>
      <start_time>10:35</start_time>
      <end_time>11:00</end_time>
      <description>We present Icicle, a pure streaming query language which statically guarantees that multiple queries over the same input stream are fused. We use a modal type system to ensure that fused queries can be computed incrementally, and a fold-based intermediate language to compile down to efficient C code. We present production benchmarks demonstrating significant speedup over existing queries written in R, and on par with the Unix tools grep and wc.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Amos</first_name>
          <last_name>Robinson</last_name>
          <affiliation>Ambiata (Australia)</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ben</first_name>
          <last_name>Lippmeier</last_name>
          <affiliation>University of New South Wales</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://benl.ouroborus.net/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/benlippmeier/9bb00e8c-9048-4fec-847b-6d7743f8fa62/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>FHPC</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a45f7513-787f-4c27-89d3-812e761d1e57</subevent_id>
    <title>FHPC: Code Generation</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/FHPC-2016-papers</url>
    <url_link_display>FHPC</url_link_display>
    <tracks>
      <track>FHPC</track>
    </tracks>
    <timeslot>
      <slot_id>5d85b062-0345-49e6-832a-681511ec58ad</slot_id>
      <title>Automatic Generation of Efficient Codes from Mathematical Descriptions of Stencil Computation</title>
      <room>Conference Room 2</room>
      <date>2016/09/22</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>Programming in HPC is a tedious work. Therefore functional programming languages that generate HPC programs have been proposed. However, they are not widely used by application scientists, because of learning barrier, and lack of demonstrated application performance.
We have designed Formura which adopts application-friendly features such as typed rational array indices. Formura users can describe mathematical concepts such as operation over derivative operators using functional programming. Formura allows intuitive expression over array elements while ensuring the program is a stencil computation, so that state-of-the-art stencil optimization techniques such as temporal blocking is always applied to Formura-generated program.
We demonstrate the usefulness of Formura by implementing a preliminary below-ground biology simulation. Optimized C-code are generated from 672 bytes of Formura program. The simulation was executed on the full nodes of the K computer, with 1.184 Pflops, 11.62% floating-point-instruction efficiency, and 31.26% memory throughput efficiency.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Takayuki</first_name>
          <last_name>Muranushi</last_name>
          <affiliation>RIKEN</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Seiya</first_name>
          <last_name>Nishizawa</last_name>
          <affiliation>RIKEN</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hirofumi</first_name>
          <last_name>Tomita</last_name>
          <affiliation>RIKEN</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Keigo</first_name>
          <last_name>Nitadori</last_name>
          <affiliation>RIKEN</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Masaki</first_name>
          <last_name>Iwasawa</last_name>
          <affiliation>RIKEN</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yutaka</first_name>
          <last_name>Maruyama</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Hisashi</first_name>
          <last_name>Yashiro</last_name>
          <affiliation>RIKEN</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Yoshifumi</first_name>
          <last_name>Nakamura</last_name>
          <affiliation>RIKEN</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Hideyuki</first_name>
          <last_name>Hotta</last_name>
          <affiliation>University of Chile, Chile</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Junichiro</first_name>
          <last_name>Makino</last_name>
          <affiliation>Kobe University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Natsuki</first_name>
          <last_name>Hosono</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>12</sort_key>
          <first_name>Hikaru</first_name>
          <last_name>Inoue</last_name>
          <affiliation>Fujitsu Limited</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>FHPC</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c698edb7-ad8d-4ae9-bdba-3c948080ad1d</slot_id>
      <title>JIT Costing Adaptive Skeletons for Performance Portability</title>
      <room>Conference Room 2</room>
      <date>2016/09/22</date>
      <start_time>12:10</start_time>
      <end_time>12:35</end_time>
      <description>The proliferation of widely available, but very different, parallel architectures makes the ability to deliver good parallel performance on a range of architectures, or performance portability, highly desirable. Irregular parallel problems, where the number and size of tasks is unpredictable, are particularly challenging and require dynamic coordination.
The paper outlines a novel approach to delivering portable parallel performance for irregular parallel programs. The approach combines JIT compiler technology with dynamic scheduling and dynamic transformation of declarative parallelism.
We specify families of algorithmic skeletons plus equations for rewriting skeleton expressions. We present the design of a framework that unfolds skeletons into task graphs, dynamically schedules tasks, and dynamically rewrites skeletons, guided by a lightweight JIT trace-based cost model, to adapt the number and granularity of tasks for the architecture.
We outline the system architecture and prototype implementation in Racket/Pycket. As the current prototype does not yet automatically perform dynamic rewriting we present results based on manual offline rewriting, demonstrating that (i) the system scales to hundreds of cores given enough parallelism of suitable granularity, and (ii) the JIT trace cost model predicts granularity accurately enough to guide rewriting towards a good adaptive transformation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Maier</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>John Magnus</first_name>
          <last_name>Motron</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Phil</first_name>
          <last_name>Trinder</last_name>
          <affiliation>University of Glasgow</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dcs.gla.ac.uk/~trinder/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>FHPC</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e55c20f8-adb2-43bd-b254-841379fe7f6a</subevent_id>
    <title>FHPC: Streaming and Dataflow</title>
    <subevent_type type="regular"/>
    <room>Conference Room 2</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/FHPC-2016-papers</url>
    <url_link_display>FHPC</url_link_display>
    <tracks>
      <track>FHPC</track>
    </tracks>
    <timeslot>
      <slot_id>a76b51db-226a-42d9-bc95-16ec93a62c61</slot_id>
      <title>Streaming Nested Data Parallelism on Multicores</title>
      <room>Conference Room 2</room>
      <date>2016/09/22</date>
      <start_time>15:20</start_time>
      <end_time>15:45</end_time>
      <description>The paradigm of nested data parallelism (NDP) allows a variety of semi-regular computation tasks to be mapped onto SIMD-style hardware, including GPUs and vector units. However, some care is needed to keep down space consumption in situations where the available parallelism may vastly exceed the available computation resources. To allow for an accurate space-cost model in such cases, we have previously proposed the Streaming NESL language, a refinement of NESL with a high-level notion of streamable sequences.
In this paper, we report on experience with a prototype implementation of Streaming NESL on a 2-level parallel platform, namely a multicore system in which we also aggressively utilize vector instructions on each core. We show that for several examples of simple, but not trivially parallelizable, text-processing tasks, we obtain single-core performance on par with off-the-shelf GNU Coreutils code, and near-linear speedups for multiple cores.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Frederik M.</first_name>
          <last_name>Madsen</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrzej</first_name>
          <last_name>Filinski</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>FHPC</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fe13e705-0e8b-4a2b-8eb0-8920183eeefb</slot_id>
      <title>Polarized Data Parallel Data Flow</title>
      <room>Conference Room 2</room>
      <date>2016/09/22</date>
      <start_time>15:45</start_time>
      <end_time>16:10</end_time>
      <description>We present an approach to writing fused data parallel data flow programs where the library API guarantees that the client programs run in constant space. Our constant space guarantee is achieved by observing that binary stream operators can be provided in several polarity versions. Each polarity version uses a different combination of stream sources and sinks, and some versions allow constant space execution while others do not. Our approach is embodied in the Repa Flow Haskell library, which we are currently using for production workloads at Vertigo.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ben</first_name>
          <last_name>Lippmeier</last_name>
          <affiliation>University of New South Wales</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://benl.ouroborus.net/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/benlippmeier/9bb00e8c-9048-4fec-847b-6d7743f8fa62/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fil</first_name>
          <last_name>Mackay</last_name>
          <affiliation>Vertigo Technology (Australia)</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Amos</first_name>
          <last_name>Robinson</last_name>
          <affiliation>Ambiata (Australia)</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>FHPC</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ca472d62-2771-4b0b-948f-10e5d51d5c0b</subevent_id>
    <title>OCaml: Session 3</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/ocaml-2016-papers</url>
    <url_link_display>OCaml</url_link_display>
    <tracks>
      <track>OCaml</track>
    </tracks>
    <timeslot>
      <slot_id>2a98992f-20f7-4c99-81f3-e08c70e85273</slot_id>
      <title>Conex -- establishing trust into data repositories</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hannes</first_name>
          <last_name>Mehnert</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Louis</first_name>
          <last_name>Gesbert</last_name>
          <affiliation>OCamlPro</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d106a154-6253-4fe6-803d-3461799e2ce9</slot_id>
      <title>OPAM-builder: Continuous Monitoring of OPAM Repositories</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>12:10</start_time>
      <end_time>12:35</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabrice</first_name>
          <last_name>Le Fessant</last_name>
          <affiliation>OCamlPro</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>065be77b-3cf1-4e2a-8f3a-ffd73fa5045a</subevent_id>
    <title>OCaml: Session 6</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/ocaml-2016-papers</url>
    <url_link_display>OCaml</url_link_display>
    <tracks>
      <track>OCaml</track>
    </tracks>
    <timeslot>
      <slot_id>56003f56-39f7-4cf5-8307-b0c088a55604</slot_id>
      <title>Improving the OCaml Web Stack: Motivations and Progress</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>17:30</start_time>
      <end_time>17:55</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Spiridon</first_name>
          <last_name>Eliopoulos</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aad709b1-5b42-4e15-b884-3a0174a6f53b</slot_id>
      <title>Closing</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>17:55</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ff332319-60ff-4ce2-b5df-d9287c649cf8</slot_id>
      <title>Who's got your Mail? Mr. Mime!</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>17:05</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Romain</first_name>
          <last_name>Calascibetta</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://din.osau.re</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/romaincalascibetta/c9af0d98-be55-46cd-bacd-9d4f55d0954f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c2d5fe36-9f72-4e94-a70d-a740ad5a5416</subevent_id>
    <title>OCaml: Session 2</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/ocaml-2016-papers</url>
    <url_link_display>OCaml</url_link_display>
    <tracks>
      <track>OCaml</track>
    </tracks>
    <timeslot>
      <slot_id>425f3e51-f98a-4c2f-bb2c-59dd6f21e474</slot_id>
      <title>Lock-free programming for the masses</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>11:05</start_time>
      <end_time>11:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>KC</first_name>
          <last_name>Sivaramakrishnan</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>I am a Post-doctoral Research Associate under the OCaml Labs initiative at the University of Cambridge Computer Lab, an 1851 Research Fellow and a Research Fellow at Darwin College, Cambridge. I am also a member of the Network and Operating Systems group.
I am interested in the design and implementation of concurrent functional programming languages targeting scalable platforms such as many-core processors and compute clouds. My research spans programming models, compilers, static analysis, schedulers, threading systems, and memory management.
Before coming to Cambridge, I was a graduate student at Purdue University where I obtained an MS and a PhD degree in Computer Science under the supervision of the wonderful Prof. Suresh Jagannathan. At Purdue, I led the MultiMLton and Quelea projects. Before that, I obtained my BEng degree in Computer Science and Engineering from Anna University, India.</bio>
          <homepage_url>http://kcsrk.info/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/kcsivaramakrishnan/8e3c8515-42d7-499a-9b77-9d8918acb314/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Théo</first_name>
          <last_name>Laurent</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7c061d80-5325-42a1-b7e7-ed4f896bead4</slot_id>
      <title>Statistically profiling memory in OCaml</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>10:40</start_time>
      <end_time>11:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jacques-Henri</first_name>
          <last_name>Jourdan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>407f219a-2e4e-4350-836c-6eee7932f683</subevent_id>
    <title>OCaml: Session 1</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/ocaml-2016-papers</url>
    <url_link_display>OCaml</url_link_display>
    <tracks>
      <track>OCaml</track>
    </tracks>
    <timeslot>
      <slot_id>4cbad87d-e26a-4ca1-b629-c3aa01c13af9</slot_id>
      <title>Invited Talk</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>09:10</start_time>
      <end_time>09:35</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Damien</first_name>
          <last_name>Doligez</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>64bd713c-41d2-4aa2-9961-4f3a716b8e93</slot_id>
      <title>Welcome</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>09:09</start_time>
      <end_time>09:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mark</first_name>
          <last_name>Shinwell</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>I am a software developer at Jane Street Europe. I spend much of my time writing code in the Objective Caml language. In my spare time I am an active caver and also play the organ. Before moving to Jane Street I worked as a GNU toolchain developer for CodeSourcery, and previous to that as a Research Associate on the EPSRC-funded project Naming, Distribution, and Versioning: Programming Language Design and Implementation at the University of Cambridge Computer Laboratory. I hold MA and PhD degrees in Computer Science from Cambridge; my doctoral work was part of the FreshML research project that finished at the end of 2004.
During my PhD work I developed the Fresh Objective Caml language, the successor to FreshML, which provides integrated support for programming with names. My PhD thesis, a runner-up in the BCS Distinguished Dissertation Awards 2005, goes into considerable detail about both pragmatic and theoretical aspects of this language.</bio>
          <homepage_url>http://www.three-tuns.net/mark/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/markshinwell/fbe66a14-690b-444c-8100-d01fc3a7d58d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c4729cde-1e94-4b46-9a6b-56e48b877901</slot_id>
      <title>The State of the OCaml Platform: September 2016</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>09:35</start_time>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>on behalf of the OCaml Platform team</role>
          <sort_key>1</sort_key>
          <first_name>Louis</first_name>
          <last_name>Gesbert</last_name>
          <affiliation>OCamlPro</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ecd912b2-47a6-476d-8889-40ec097d6500</slot_id>
      <title>Learn OCaml: An Online Learning Center for OCaml</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>10:00</start_time>
      <end_time>10:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Canou</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Grégoire</first_name>
          <last_name>Henry</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Çagdas</first_name>
          <last_name>Bozman</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fabrice</first_name>
          <last_name>Le Fessant</last_name>
          <affiliation>OCamlPro</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a20f29bd-5cbd-44f1-9b5b-2a53a54df0d3</subevent_id>
    <title>OCaml: Session 5</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/ocaml-2016-papers</url>
    <url_link_display>OCaml</url_link_display>
    <tracks>
      <track>OCaml</track>
    </tracks>
    <timeslot>
      <slot_id>6cb1caf0-b456-4170-8114-6bfdcf17b8a5</slot_id>
      <title>Semantics of the Lambda intermediate language</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>15:20</start_time>
      <end_time>15:45</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Chambart</last_name>
          <affiliation>OCamlPRO</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f3de3591-7c33-4b3f-bb4c-aa991814ff62</slot_id>
      <title>Generic Programming in OCaml</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>15:45</start_time>
      <end_time>16:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florent</first_name>
          <last_name>Balestrieri</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michel</first_name>
          <last_name>Mauny</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3299a77f-5aea-463c-a538-c69f2099d35e</subevent_id>
    <title>OCaml: Session 4 </title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/ocaml-2016-papers</url>
    <url_link_display>OCaml</url_link_display>
    <tracks>
      <track>OCaml</track>
    </tracks>
    <timeslot>
      <slot_id>5e4ed8ca-611d-4dcc-a309-13744e0bc0d9</slot_id>
      <title>Sundials/ML: interfacing with numerical solvers</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Timothy</first_name>
          <last_name>Bourke</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tbrk.org</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/timothybourke/747739f4-e5f1-4d96-957d-a9e98c1ba4f7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jun</first_name>
          <last_name>Inoue</last_name>
          <affiliation>National Institute of Advanced Industrial Science and Technology, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marc</first_name>
          <last_name>Pouzet</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8f90eca9-3de3-4ab1-8880-fb059406a0ec</slot_id>
      <title>OCaml inside: a drop-in replacement for libtls</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Enguerrand</first_name>
          <last_name>Decorne</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Yallop</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~jdy22/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Kaloper-Mersinjak</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b07ad6d1-4935-4d83-a0b5-6744b6a44bd5</subevent_id>
    <title>OCaml: Break and Poster Session</title>
    <subevent_type type="regular"/>
    <room>Conference Room 1</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/ocaml-2016-papers</url>
    <url_link_display>OCaml</url_link_display>
    <tracks>
      <track>OCaml</track>
    </tracks>
    <timeslot>
      <slot_id>15ed38de-2db2-4ba7-bee5-78d1c77084c9</slot_id>
      <title>Partial evaluation and metaprogramming</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>16:46</start_time>
      <end_time>17:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Chambart</last_name>
          <affiliation>OCamlPRO</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4aa19890-de85-4bfd-af9d-3238d0335019</slot_id>
      <title>ocp-lint, A Plugin-based Style-Checker with Semantic Patches</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>16:28</start_time>
      <end_time>16:46</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Çagdas</first_name>
          <last_name>Bozman</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Théophane</first_name>
          <last_name>Hufschmitt</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Laporte</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fabrice</first_name>
          <last_name>Le Fessant</last_name>
          <affiliation>OCamlPro</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a6caa57f-969d-4b66-8a0e-028b64f570b7</slot_id>
      <title>Inuit library: from printf to interactive user-interfaces</title>
      <room>Conference Room 1</room>
      <date>2016/09/23</date>
      <start_time>16:10</start_time>
      <end_time>16:28</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Frédéric</first_name>
          <last_name>Bour</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OCaml</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>28310969-6845-416d-b2c4-ff272dece4d5</subevent_id>
    <title>Tutorials: T8</title>
    <subevent_type type="regular"/>
    <room>Conference Room 5</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-Tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>191768ae-d706-4ab3-8360-7c89ffe3f29b</slot_id>
      <title>T8: Transforming data into GUI: a new style graphical user interface library for Haskell</title>
      <room>Conference Room 5</room>
      <date>2016/09/23</date>
      <start_time>14:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fumiaki</first_name>
          <last_name>Kinoshita</last_name>
          <affiliation>Tsuru Capital</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d435ed84-3590-4cb0-908e-f7cde5b476f8</subevent_id>
    <title>Tutorials: T3</title>
    <subevent_type type="regular"/>
    <room>Conference Room 6</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-Tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>36dbe3f9-faab-419e-ba7a-af7ede272ff1</slot_id>
      <title>T3: Introduction to OCaml</title>
      <room>Conference Room 6</room>
      <date>2016/09/22</date>
      <start_time>14:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>KC</first_name>
          <last_name>Sivaramakrishnan</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>I am a Post-doctoral Research Associate under the OCaml Labs initiative at the University of Cambridge Computer Lab, an 1851 Research Fellow and a Research Fellow at Darwin College, Cambridge. I am also a member of the Network and Operating Systems group.
I am interested in the design and implementation of concurrent functional programming languages targeting scalable platforms such as many-core processors and compute clouds. My research spans programming models, compilers, static analysis, schedulers, threading systems, and memory management.
Before coming to Cambridge, I was a graduate student at Purdue University where I obtained an MS and a PhD degree in Computer Science under the supervision of the wonderful Prof. Suresh Jagannathan. At Purdue, I led the MultiMLton and Quelea projects. Before that, I obtained my BEng degree in Computer Science and Engineering from Anna University, India.</bio>
          <homepage_url>http://kcsrk.info/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/kcsivaramakrishnan/8e3c8515-42d7-499a-9b77-9d8918acb314/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>89f10a30-737b-4bde-83f2-33a9d128e046</subevent_id>
    <title>Tutorials: T7</title>
    <subevent_type type="regular"/>
    <room>Conference Room 6</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-Tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>20ab7c78-5390-434b-a65f-fa6cb500fdcc</slot_id>
      <title>T7: PureScript Front-end Developement</title>
      <room>Conference Room 6</room>
      <date>2016/09/23</date>
      <start_time>14:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Brian</first_name>
          <last_name>McKenna</last_name>
          <affiliation>Atlassian</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://brianmckenna.org/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1ede51bc-260f-4ddd-9c53-5b57bb75e5e7</subevent_id>
    <title>Tutorials: T1</title>
    <subevent_type type="regular"/>
    <room>Conference Room 6</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-Tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>2bc0d18b-57c7-4d77-8ea6-8307222e2714</slot_id>
      <title>T1: Teaching Functional Programming</title>
      <room>Conference Room 6</room>
      <date>2016/09/22</date>
      <start_time>09:15</start_time>
      <end_time>12:45</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Sperber</last_name>
          <affiliation>Active Group GmbH</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://deinprogramm.de/sperber/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/michaelsperber/e0008500-aa96-40e3-87f9-afe454474878/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fd11c450-4209-408c-a62d-3b8ae7f5b7cf</subevent_id>
    <title>Tutorials: T2</title>
    <subevent_type type="regular"/>
    <room>Conference Room 5</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-Tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>d81f3285-6a54-4992-a9ff-f84cce49885b</slot_id>
      <title>T2: Extensible Effects: understanding them, implementing them, using them</title>
      <room>Conference Room 5</room>
      <date>2016/09/22</date>
      <start_time>09:15</start_time>
      <end_time>12:45</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oleg</first_name>
          <last_name>Kiselyov</last_name>
          <affiliation>Tohoku University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://okmij.org/ftp/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/olegkiselyov/575daa05-880d-4f2f-b085-acbece1d264e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2a7d2ded-f7ef-4177-9714-4110fd2516cd</subevent_id>
    <title>Tutorials: T6</title>
    <subevent_type type="regular"/>
    <room>Conference Room 5</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-Tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>ae161ed2-5b6c-43e4-a1c3-f228c8b4288f</slot_id>
      <title>T6: LiquidHaskell: Verification of Haskell Programs with SMTs</title>
      <room>Conference Room 5</room>
      <date>2016/09/23</date>
      <start_time>09:15</start_time>
      <end_time>12:45</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Niki</first_name>
          <last_name>Vazou</last_name>
          <affiliation>UC San Diego</affiliation>
          <bio>I am a 5th year PhD student in Programming Systems group of UCSD, supervised by Ranjit Jhala. My research interests include static program verification and type systems. I am working on LiquidHaskell, a static verifier for Haskell based on Liquid Types.</bio>
          <homepage_url>http://goto.ucsd.edu/~nvazou/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ba059d2b-61af-4596-a85f-61b4a22fc4e3</subevent_id>
    <title>Tutorials: T4</title>
    <subevent_type type="regular"/>
    <room>Conference Room 5</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-Tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>c9a5fcf3-7d61-4af3-b6a0-ed55a9f62586</slot_id>
      <title>T4: An Introduction to to Type-Level and Generic Programming in Haskell</title>
      <room>Conference Room 5</room>
      <date>2016/09/22</date>
      <start_time>14:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andres</first_name>
          <last_name>Löh</last_name>
          <affiliation>Well-Typed LLP</affiliation>
          <bio>Since 2010, I am a partner and Haskell Consultant at Well-Typed LLP.</bio>
          <homepage_url>http://www.andres-loeh.de/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/andresloh/d7276ea5-1b0c-4d50-9ffb-6cadab33f624/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>04e2c332-b56d-4136-91fa-35ab05fd768b</subevent_id>
    <title>Tutorials: T5</title>
    <subevent_type type="regular"/>
    <room>Conference Room 6</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-Tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>fd96b1eb-d905-42e7-ad0b-db29904b5647</slot_id>
      <title>T5: Fable, an F# to JavaScript compiler</title>
      <room>Conference Room 6</room>
      <date>2016/09/23</date>
      <start_time>09:15</start_time>
      <end_time>12:45</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alfonso</first_name>
          <last_name>Garcia-Caro</last_name>
          <affiliation>undefined</affiliation>
          <bio>.NET/JS developer of eclectic background. After getting a degree in Linguistics, he lived and worked in Japan and Germany before going back to this home country, Spain. He’s developed different kind of applications like CAT (Computer Aided Translation) software. His interest in functional programming and web development led him to create Fable, an F# to JS compiler, which has quickly become very popular in the F# community. International speaker, has presented about F# and his projects in the US, UK, Japan and Spain. Currently also learning about Machine Learning and finishing a book on F#. Twitter: @alfonsogcnunez</bio>
          <homepage_url>https://fable-compiler.github.io/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/alfonsogarciacaro/c7d1ea63-6ca5-4c1a-9e68-c298d9e148a3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b2ba96e9-192f-4907-bb6d-9bcd982e0392</subevent_id>
    <title>Haskell: Abstractions that Scale</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/haskellsymp-2016-papers</url>
    <url_link_display>Haskell</url_link_display>
    <tracks>
      <track>Haskell</track>
    </tracks>
    <timeslot>
      <slot_id>cacbab5d-a324-4fd9-aa2c-394c2800969f</slot_id>
      <title>Non-recursive Make Considered Harmful: Build Systems at Scale</title>
      <room>Noh Theater</room>
      <date>2016/09/23</date>
      <start_time>15:20</start_time>
      <end_time>15:45</end_time>
      <description>Most build systems start small and simple, but over time grow into hairy monstersthat few dare to touch. As we demonstrate in this paper, there are a few issuesthat cause build systems major scalability challenges, and many pervasivelyused build systems (e.g. Make) do not scale well. 
This paper presents a solution to the challenges we identify. We use functionalprogramming to design abstractions for build systems, and implementthem on top of the Shake library, which allows us to describe build rules anddependencies. To substantiate our claims, we engineer a new build systemfor the Glasgow Haskell Compiler. The result is more scalable, faster, andspectacularly more maintainable than its Make-based predecessor.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andrey</first_name>
          <last_name>Mokhov</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neil</first_name>
          <last_name>Mitchell</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Simon</first_name>
          <last_name>Peyton Jones</last_name>
          <affiliation>Microsoft Research, UK</affiliation>
          <bio>Simon Peyton Jones, MA, MBCS, CEng, graduated from Trinity College Cambridge in 1980. After two years in industry, he spent seven years as a lecturer at University College London, and nine years as a professor at Glasgow University, before moving to Microsoft Research (Cambridge) in 1998. His main research interest is in functional programming languages, their implementation, and their application. He has led a succession of research projects focused around the design and implementation of production-quality functional-language systems for both uniprocessors and parallel machines. He was a key contributor to the design of the now-standard functional language Haskell, and is the lead designer of the widely-used Glasgow Haskell Compiler (GHC). He has written two textbooks about the implementation of functional languages.
More generally, he is interested in language design, rich type systems, software component architectures, compiler technology, code generation, runtime systems, virtual machines, and garbage collection. He is particularly motivated by direct use of principled theory to practical language design and implementation – that’s one reason he loves functional programming so much.</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/simonpaytonjones/6128a22a-7036-4d52-90ac-2b1b5be66354/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Simon</first_name>
          <last_name>Marlow</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Simon Marlow is a Software Engineer on Facebook’s Site Integrity Infrastructure team in London. He is working on Haxl, a Haskell-based domain-specific language that is used by the teams fighting spam and malware. Simon is a co-author of the Glasgow Haskell Compiler, author of the book “Parallel and Concurrent Programming in Haskell”, and has a string of research publications in functional programming, language design, compilers, and language implementation.</bio>
          <homepage_url>http://community.haskell.org/~simonmar/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/simonmarlow/d6f3111f-a2c1-4f7f-af4b-7744c18ea27e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fdba6c02-782d-4d8f-8c80-067179c20852</slot_id>
      <title>Lazy Graph Processing in Haskell</title>
      <room>Noh Theater</room>
      <date>2016/09/23</date>
      <start_time>15:45</start_time>
      <end_time>16:10</end_time>
      <description>This paper presents a Haskell library for graph processing:DeltaGraph. One unique feature of this system is that intentionsto perform graph updates can be memoized \emph{in-graph} in adecentralized fashion, and the propagation of these intentionswithin the graph can be decoupled from the realization of theupdates. As a result, DeltaGraph can respond to updates inconstant time and work elegantly with parallelism support. Webuild a Twitter-like application on top of DeltaGraph todemonstrate its effectiveness and explore parallelism andopportunistic computing optimizations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Philip</first_name>
          <last_name>Dexter</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yu David</first_name>
          <last_name>Liu</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kenneth</first_name>
          <last_name>Chiu</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ee596306-c0cb-4ac2-8cc8-f6e127556517</subevent_id>
    <title>Research Papers: Session 6</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/20</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>6d81a3bc-4f81-4916-893d-8626a8091a5c</slot_id>
      <title>Dynamic Witnesses for Static Type Errors (or, Ill-Typed Programs Usually Go Wrong)</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>13:30</start_time>
      <end_time>13:55</end_time>
      <description>Static type errors are a common stumbling block for newcomers to typed functional languages. We present a dynamic approach to explaining type errors by generating counterexample witness inputs that illustrate how an ill-typed program goes wrong. First, given an ill-typed function, we symbolically execute the body to synthesize witness values that make the program go wrong. We prove that our procedure synthesizes general witnesses in that if a witness is found, then for all inhabited input types, there exist values that can make the function go wrong. Second, we show how to extend the above procedure to produce a reduction graph that can be used to interactively visualize and debug witness executions. Third, we evaluate the coverage of our approach on two data sets comprising over 4,500 ill-typed student programs. Our technique is able to generate witnesses for 88% of the programs, and our reduction graph yields small counterexamples for 81% of the witnesses. Finally, we evaluate whether our witnesses help students understand and fix type errors, and find that students presented with our witnesses show a greater understanding of type errors than those presented with a standard error message.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric L.</first_name>
          <last_name>Seidel</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://eric.seidel.io</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/ericseidel/4929cfc4-b061-49e9-9746-7c85b3b680b4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ranjit</first_name>
          <last_name>Jhala</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>I am an Associate Professor in the Department of Computer Science, Jacobs School of Engineering, at the University of California, San Diego, CA, USA.
Research Interests: I am interested in Programming Languages and Software Engineering, more specifically, in techniques for building reliable computer systems. My work draws from, combines and contributes to the areas of Model Checking, Program Analysis and Automated Deduction.</bio>
          <homepage_url>http://goto.ucsd.edu/~rjhala/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/ranjitjhala/7caf970e-726b-4661-be22-94492edb4cf7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Westley</first_name>
          <last_name>Weimer</last_name>
          <affiliation>University of Virginia, USA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8573e5d6-580c-44e9-afe1-1ba6b20f63ee</slot_id>
      <title>Higher-Order Ghost State</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>14:20</start_time>
      <end_time>14:45</end_time>
      <description>The development of concurrent separation logic (CSL) has sparked a long line of work on modular verification of sophisticated concurrent programs. Two of the most important features supported by several existing extensions to CSL are higher-order quantification and custom ghost state. However, none of the logics that support both of these features reap the full potential of their combination. In particular, none of them provide general support for a feature we dub &amp;quot;higher-order ghost state&amp;quot;: the ability to store arbitrary higher-order separation-logic predicates in ghost variables. 
In this paper, we propose higher-order ghost state as a interesting and useful extension to CSL, which we formalize in the framework of Jung et al.'s recently developed Iris logic. To justify its soundness, we develop a novel algebraic structure called CMRAs (&amp;quot;cameras&amp;quot;), which can be thought of as &amp;quot;step-indexed partial commutative monoids&amp;quot;. Finally, we show that Iris proofs utilizing higher-order ghost state can be effectively formalized in Coq, and discuss the challenges we faced in formalizing them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ralf</first_name>
          <last_name>Jung</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~jung/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lars</first_name>
          <last_name>Birkedal</last_name>
          <affiliation>Aarhus University, Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~birke/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/larsbirkedal/c7844c55-6fb8-44e5-ad4d-45b69ae0dea8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Derek</first_name>
          <last_name>Dreyer</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~dreyer</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/derekdreyer/fa38ae17-ad43-4448-b1d5-20bb6e281012/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f9eee6c0-0db1-403c-a903-1406c6cec8a1</slot_id>
      <title>Automatically Disproving Fair Termination of Higher-Order Functional Programs</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>13:55</start_time>
      <end_time>14:20</end_time>
      <description>We propose an automated method for disproving fair termination of higher-order functional programs, which is complementary to Murase et al.'s recent method for proving fair termination. A program is said to be fair terminating if it has no infinite execution trace that satisfies a given fairness constraint. Fair termination is an important property because program verification problems for arbitrary ω-regular temporal properties can be transformed to those of fair termination. Our method reduces the problem of disproving fair termination to higher-order model checking by using predicate abstraction and CEGAR. Given a program, we convert it to an abstract program that generates an approximation of the (possibly infinite) execution traces of the original program, so that the original program has a fair infinite execution trace if the tree generated by the abstract program satisfies a certain property. The method is a non-trivial extension of Kuwahara et al.'s method for disproving plain termination.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Keiichi</first_name>
          <last_name>Watanabe</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ryosuke</first_name>
          <last_name>Sato</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Takeshi</first_name>
          <last_name>Tsukada</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c986bf77-a992-4410-b6b1-f398f089f90f</subevent_id>
    <title>Research Papers: Session 11</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/21</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>15040abf-b7e3-4a91-9937-28135e51daef</slot_id>
      <title>Talking Bananas: Structural Recursion for Session Types</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>15:05</start_time>
      <end_time>15:30</end_time>
      <description>Session types provide static guarantees that concurrent programs respect communication protocols. We give a novel account of recursive session types in the context of GV, a small concurrent extension of the linear λ-calculus. We extend GV with recursive types and catamorphisms, following the initial algebra semantics of recursion, and show that doing so naturally gives rise to recursive session types. We show that this principled approach to recursion resolves long-standing problems in the treatment of duality for recursive session types. 
We characterize the expressiveness of GV concurrency by giving a CPS translation to (non-concurrent) λ-calculus and proving that reduction in GV is simulated by full reduction in λ-calculus. This shows that GV remains terminating in the presence of positive recursive types, and that such arguments extend to other extensions of GV, such as polymorphism or non-linear types, by appeal to normalization results for sequential λ-calculi. We also show that GV remains deadlock free and deterministic in the presence of recursive types. 
Finally, we extend CP, a session-typed process calculus based on linear logic, with recursive types, and show that doing so preserves the connection between reduction in GV and cut elimination in CP.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sam</first_name>
          <last_name>Lindley</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/slindley/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/samlindley/32dd34f2-c14b-412f-811e-449bbff76c7f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>J. Garrett</first_name>
          <last_name>Morris</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jgbm.github.io</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/jgarrettmorris/bfd0d5b6-e65e-403e-882f-089258565ed5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>174f8978-0b31-43b7-a54f-ffae85839de6</slot_id>
      <title>The Best of Both Worlds: Linear Functional Programming without Compromise</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>15:30</start_time>
      <end_time>15:55</end_time>
      <description>We present a linear functional calculus with both the safety guarantees expressible with linear types and the rich language of combinators and composition provided by functional programming. Unlike previous combinations of linear typing and functional programming, we compromise neither the linear side (for example, our linear values are first-class citizens of the language) nor the functional side (for example, we do not require duplicate definitions of compositions for linear and unrestricted functions). To do so, we must generalize abstraction and application to encompass both linear and unrestricted functions. We capture the typing of the generalized constructs with a novel use of qualified types. Our system maintains the metatheoretic properties of the theory of qualified types, including principal types and decidable type inference. Finally, we give a formal basis for our claims of expressiveness, by showing that evaluation respects linearity, and that our language is a conservative extension of existing functional calculi.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>J. Garrett</first_name>
          <last_name>Morris</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jgbm.github.io</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/jgarrettmorris/bfd0d5b6-e65e-403e-882f-089258565ed5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7a71993b-093f-4a01-a3b5-3e93686b9cdf</slot_id>
      <title>Context-Free Session Types</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>15:55</start_time>
      <end_time>16:20</end_time>
      <description>Session types describe structured communication on heterogeneouslytyped channels at a high level.Their tail-recursive structure imposes a protocol that can bedescribed by a regular language.The types of transmitted values are drawn from the underlyingfunctional language, abstracting from thedetails of serializing values of structured data types. 
Context-free session types extend session types by allowing nestedprotocols that are not restricted to tail recursion. Nested protocolscorrespond to deterministic context-free languages. Such protocols areinteresting in their own right, but they are particularly suited todescribe the low-level serialization of tree-structured data in atype-safe way. 
We establish the metatheory of context-free session types, prove thatthey properly generalize standard (two-party) sessiontypes, and take first steps towards type checking by showingthat type equivalence is decidable.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Peter</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www2.informatik.uni-freiburg.de/~thiemann/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/peterthiemann/e05f6038-4b5e-4c38-91bb-a460b5d8d756/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vasco</first_name>
          <last_name>Thudichum Vasconcelos</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>975c3b16-a530-4302-b59b-0d22ea92090b</subevent_id>
    <title>Haskell: Monads</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/haskellsymp-2016-papers</url>
    <url_link_display>Haskell</url_link_display>
    <tracks>
      <track>Haskell</track>
    </tracks>
    <timeslot>
      <slot_id>1ba965a6-8273-41c4-b9eb-930bf3d1348e</slot_id>
      <title>Supermonads: One Notion to Bind Them All</title>
      <room>Noh Theater</room>
      <date>2016/09/23</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>Several popular generalizations of monads have beenimplemented in Haskell. Unfortunately, because the shape of the associated type constructors do not match the standard Haskell monad interface, each such implementation provides its own type class and versions of associated library functions. Furthermore, simultaneous use of different monadic notions can be cumbersome as it in general is necessary to be explicit about which notion is used where. In this paper we introduce \emph{supermonads}: an encoding of monadic notions that captures several different generalizations along with a version of the standard library of monadic functions that work uniformly with all of them.As standard Haskell type inference does not work for supermonads due to their generality, our supermonad implementation is accompanied with a language extension, in the form of a pluginfor the Glasgow Haskell Compiler (GHC), that allows type inferencefor supermonads, obviating the need for manual annotations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>Bracker</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Henrik</first_name>
          <last_name>Nilsson</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8ee63fad-955c-45ea-a701-40fc3b5e78ac</slot_id>
      <title>The Key Monad: Type-Safe Unconstrained Dynamic Typing</title>
      <room>Noh Theater</room>
      <date>2016/09/23</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>We present a small extension to Haskell called the Key monad. With the Key monad, unique keys of different types can be created and can be tested for equality. When two keys are equal, we also obtain a concrete proof that their types are equal. This gives us a form of dynamic typing, without the need for Typeable constraints. We show that our extension allows us to safely do things we could not otherwise do: it allows us to implement the ST monad (inefficiently), to implement an embedded form of arrow notation, and to translate parametric HOAS to typed de Bruijn indices, among others. Although strongly related to the ST monad, the Key monad is simpler and might be easier to prove safe. We do not provide such a proof of the safety of the Key monad, but we note that, surprisingly, a full proof of the safety of the ST monad also remains elusive to this day. Hence, another reason for studying the Key monad is that a safety proof for it might be a stepping stone towards a safety proof of the ST monad.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pablo</first_name>
          <last_name>Buiras</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~buiras/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Koen</first_name>
          <last_name>Claessen</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~koen/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/koenclaessen/893f5363-3c94-4f98-a251-06c021537878/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Atze</first_name>
          <last_name>van der Ploeg</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cab96c15-f292-4b29-967c-2fb82da5ce0c</subevent_id>
    <title>Research Papers: Session 1</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/19</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>0a4230ad-aeb2-4b82-8933-d1ede222142a</slot_id>
      <title>Deriving a Probability Density Calculator (Functional Pearl)</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>12:00</start_time>
      <end_time>12:25</end_time>
      <description>Given an expression that denotes a probability distribution, often we want a corresponding density function, to use in probabilistic inference. Fortunately, the task of finding a density has been automated. It turns out that we can derive a compositional procedure for finding a density, by equational reasoning about integrals, starting with the mathematical specification of what a density is. Moreover, the density found can be run as an estimation algorithm, as well as simplified as an exact formula to improve the estimate.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wazim</first_name>
          <last_name>Mohammed Ismail</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.linkedin.com/in/wazimismail</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/wazimmohammedismail/2bad9693-1619-4f6b-8fa6-549cabe6c3ba/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chung-chieh</first_name>
          <last_name>Shan</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.soic.indiana.edu/ccshan/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/chungchiehshan/5f1d6cc2-6e76-484a-bafe-85460ba4c6e5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>18e53e73-6d31-47a5-833e-290020fa0eb0</slot_id>
      <title>A Lambda-Calculus Foundation for Universal Probabilistic Programming</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>11:35</start_time>
      <end_time>12:00</end_time>
      <description>We develop the operational semantics of an untyped probabilistic $\lambda$-calculus with continuous distributions, and both hard and soft constraints,as a foundation for universal probabilistic programming languages such as Church, Anglican, and Venture. Our first contribution is to adapt the classic operational semantics oλ-calculus to a continuous setting via creating a measure space on terms and defining step-indexed approximations. We prove equivalence of big-step and small-step formulations of this distribution-based semantics. To move closer to inference techniques, we also define the sampling-based semantics of a term as a function from a trace of random samples to a value. We show that the distribution induced by integration over the space of traces equals the distribution-based semantics. Our second contribution is to formalize the implementation technique of trace Markov chain Monte Carlo (MCMC) for our calculus and to show its correctness. A key step is defining sufficient conditions for the distribution induced by trace MCMC to converge to the distribution-based semantics. To the best of our knowledge, this is the first rigorous correctness proof for trace MCMC for a higher-order functional language, or for a language with soft constraints.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Borgström</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://johannes.borgstroem.org/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/johannesborgstrom/0437a8f1-262d-49c7-8e29-9fcb98748d31/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ugo</first_name>
          <last_name>Dal Lago</last_name>
          <affiliation>University of Bologna, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew D.</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Microsoft Research, UK</affiliation>
          <bio>I am a Principal Researcher at Microsoft Research, Cambridge, where I manage Programming Principles and Tools. As a part-time position, I also hold the Chair in Computer Security and am a member of the Laboratory for Foundations of Computer Science and the Security and Privacy group in the School of Informatics in the University of Edinburgh. I convene the University of Edinburgh Microsoft Research Joint Initiative in Informatics. I participate in the Data Science PhD programme. My current research is on probabilistic programming for machine learning.</bio>
          <homepage_url>https://onedrive.live.com/view.aspx/adg?cid=c6149b019d236bf5</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/andrewdgordon/6a7c06a4-cf70-4529-ad02-55b979e93f82/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Marcin</first_name>
          <last_name>Szymczak</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3d621c1e-5e3b-467c-a10a-639a8f5e73d4</slot_id>
      <title>Farms, Pipes, Streams and Reforestation: Reasoning about Structured Parallel Processes using Types and Hylomorphisms</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>10:45</start_time>
      <end_time>11:10</end_time>
      <description>The increasing importance of parallelism has motivated the creation of better abstractions for writing parallel software, including structured parallelism using nested algorithmic skeletons. Such approaches provide high-level abstractions that avoid common problems, such as race conditions, and often allow strong cost models to be defined. However, choosing a combination of algorithmic skeletons that yields good parallel speedups for a program on some specific parallel architecture remains a difficult task. In order to achieve this, it is necessary to simultaneously reason both about the costs of different parallel structures and about the semantic equivalences between them. This paper presents a new type-based mechanism that enables strong static reasoning about these properties. We exploit well-known properties of a very general recursion pattern, hylomorphisms, and give a denotational semantics for structured parallel processes in terms of these hylomorphisms. Using our approach, it is possible to determine formally whether it is possible to introduce a desired parallel structure into a program without altering its functional behaviour, and also to choose a version of that parallel structure that minimises some given cost model.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Castro</last_name>
          <affiliation>University of St. Andrews, UK</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Hammond</last_name>
          <affiliation>University of St. Andrews, UK</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Susmit</first_name>
          <last_name>Sarkar</last_name>
          <affiliation>University of St. Andrews, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.cs.st-andrews.ac.uk/~ss265</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>552bc674-afc4-43c9-b35a-e8986428009c</slot_id>
      <title>Dag-Calculus: A Calculus for Parallel Computation</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>11:10</start_time>
      <end_time>11:35</end_time>
      <description>Increasing availability of multicore systems has led to greater focus on the design and implementation of languages for writing parallel programs. Such languages support various abstractions for parallelism, such as fork-join, async-finish, futures. While they may seem similar, these abstractions lead to different semantics, language design and implementation decisions, and can significantly impact the performance of end-user applications.
In this paper, we consider the question of whether it would be possible to unify various paradigms of parallel computing. To this end, we propose a calculus, called dag calculus, that can encode fork-join, async-finish, and futures, and possibly others. We describe dag calculus and its semantics, establish translations from the aforementioned paradigms into dag calculus. These translations establish that dag calculus is sufficiently powerful for encoding programs written in prevailing paradigms of parallelism. We present concurrent algorithms and data structures for realizing dag calculus on multicore hardware and prove that the proposed techniques are consistent with the semantics. Finally, we present an implementation of the calculus and evaluate it empirically by comparing its performance to highly optimized code from prior work. The results show that the calculus is expressive and that it competes well with, and sometimes outperforms, the state of the art.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Umut</first_name>
          <last_name>Acar</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arthur</first_name>
          <last_name>Charguéraud</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arthur.chargueraud.org/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/arthurchargueraud/9aed9f5a-138b-4fa1-93bd-f97952267417/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mike</first_name>
          <last_name>Rainey</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gallium.inria.fr/~rainey/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/mikerainey/c6ac4f11-4b95-4867-9d94-476a32e260fe/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Filip</first_name>
          <last_name>Sieczkowski</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/filipsieczkowski/798bba62-e2ef-466f-8548-ab13f479cd83/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3adee6f9-3725-4d13-9587-fd486096f14c</subevent_id>
    <title>Haskell: Types</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/haskellsymp-2016-papers</url>
    <url_link_display>Haskell</url_link_display>
    <tracks>
      <track>Haskell</track>
    </tracks>
    <timeslot>
      <slot_id>0599122c-0742-444f-91a2-aee357f076e8</slot_id>
      <title>Embedding Session Types in Haskell</title>
      <room>Noh Theater</room>
      <date>2016/09/23</date>
      <start_time>11:00</start_time>
      <end_time>11:25</end_time>
      <description>We present a novel embedding of session-typed concurrency in Haskell. We extend an existing HOAS embedding of linear $\lambda$-calculus with a set of core session-typed primitives, using indexed type families to express the constraints of the session typing discipline. We give two interpretations of our embedding, one in terms of GHC's built-in concurrency and another in terms of purely functional continuations. Our safety guarantees, including deadlock freedom, are assured statically and introduce no additional runtime overhead.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sam</first_name>
          <last_name>Lindley</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/slindley/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/samlindley/32dd34f2-c14b-412f-811e-449bbff76c7f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>J. Garrett</first_name>
          <last_name>Morris</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jgbm.github.io</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/jgarrettmorris/bfd0d5b6-e65e-403e-882f-089258565ed5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>19230d3f-cba6-4d45-b5d1-4be539d54795</slot_id>
      <title>Experience Report: Types for a Relational Algebra Library</title>
      <room>Noh Theater</room>
      <date>2016/09/23</date>
      <start_time>10:35</start_time>
      <end_time>11:00</end_time>
      <description>As part of our software toolkit at a major financial institutionwe have a library for relational algebra.This library is written in C++ and the type checking of the operations on the relations is very dynamic; all relations have the same static type.Of course, relational algebra operations have stringent type constraints,and since we believe in static typing, we would prefer these to be checked at compile time. 
We have managed to get full static type checking of the relational code,using some modern extensions to the Haskell type system, such asclosed type families, type level strings, user-defined kinds, and custom type errors.The static type checking incurs no runtime overhead compared to the dynamically checked library. 
Some effort has gone into making the use of the typed library similar to the dynamically typed version.We have also tried to produce good error messages when something is wrong.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marten</first_name>
          <last_name>Agren</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lennart</first_name>
          <last_name>Augustsson</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b217d0e3-0291-4318-b639-1e1c760b42f7</subevent_id>
    <title>Research Papers: Session 10</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/21</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>43320f8a-b599-484a-a57d-7db2b367a428</slot_id>
      <title>Allocation Characterizes Polyvariance: A Unified Methodology for Polyvariant Control-Flow Analysis</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>13:55</start_time>
      <end_time>14:20</end_time>
      <description>The polyvariance of a static analysis is the degree to which it structurally differentiates approximations of program values. Polyvariant techniques come in a number of different flavors that represent alternative heuristics for managing the trade-off an analysis strikes between precision and complexity. For example, call sensitivity supposes that values will tend to correlate with recent call sites, object sensitivity supposes that values will correlate with the allocation points of related objects, the Cartesian product algorithm supposes correlations between the values of arguments to the same function, and so forth. 
In this paper, we describe a unified methodology for implementing and understanding polyvariance in a higher-order setting (i.e., for control-flow analyses). We do this by extending the method of abstracting abstract machines (AAM), a systematic approach to producing an abstract interpretation of abstract-machine semantics. AAM eliminates recursion within a language’s semantics by passing around an explicit store, and thus places importance on the strategy an analysis uses for allocating abstract addresses within the abstract heap or store. We build on AAM by showing that the design space of possible abstract allocators exactly and uniquely corresponds to the design space of polyvariant strategies. This allows us to both unify and generalize polyvariance as tunings of a single function. Changes to the behavior of this function easily recapitulate classic styles of analysis and produce novel variations, combinations of techniques, and fundamentally new techniques.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Gilray</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael D.</first_name>
          <last_name>Adams</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Might</last_name>
          <affiliation>University of Utah, USA</affiliation>
          <bio>Associate Professor in Computing Science at the University of Utah. 
Visiting Associate Professor at the Harvard Medical School. 
Strategist in the Executive Office of the President at The White House.</bio>
          <homepage_url>http://matt.might.net/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/matthewmight/f660997f-e8d1-4f78-9a97-396d4da34536/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>54387295-91b9-49d3-a507-cd1da624f4ed</slot_id>
      <title>Hierarchical Memory Management for Parallel Programs</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>13:30</start_time>
      <end_time>13:55</end_time>
      <description>An important feature of functional programs is that they are parallel by default. Implementing an efficient parallel functional language, however, is a major challenge, in part because the high rate of allocation and freeing associated with functional programs requires an efficient and scalable memory manager. 
In this paper, we present a technique for parallel memory management for strict functional languages with nested parallelism. At the highest level of abstraction, the approach consists of a technique to organize memory as a hierarchy of heaps, and an algorithm for performing automatic memory reclamation by taking advantage of a disentanglement property of parallel functional programs. More specifically, the idea is to assign to each parallel task its own heap in memory and organize the heaps in a hierarchy/tree that mirrors the hierarchy of tasks. 
We present a nested-parallel calculus that specifies hierarchical heaps and prove in this calculus a disentanglement property, which prohibits a task from accessing objects allocated by another task that might execute in parallel. Leveraging the disentanglement property, we present a garbage collection technique that can operate on any subtree in the memory hierarchy concurrently as other tasks (and/or other collections) proceed in parallel. We prove the safety of this collector by formalizing it in the context of our parallel calculus. In addition, we describe how the proposed techniques can be implemented on modern shared-memory machines and present a prototype implementation as an extension to MLton, a high-performance compiler for the Standard ML language. Finally, we evaluate the performance of this implementation on a number of parallel benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ram</first_name>
          <last_name>Raghunathan</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stefan K.</first_name>
          <last_name>Muller</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Umut</first_name>
          <last_name>Acar</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Guy</first_name>
          <last_name>Blelloch</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>815ae499-bcf6-4a4f-b622-b8c7baa917bb</slot_id>
      <title>A Fully Concurrent Garbage Collector for Functional Programs on Multicore Processors</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>14:20</start_time>
      <end_time>14:45</end_time>
      <description>This paper presents a concurrent garbage collection methodfor functional programs running on a multicore processor.It is a concurrent extension of our bitmap-marking non-movingcollector with Yuasa's snapshot-at-the-beginning strategy.Our collector is unobtrusive in the sense ofthe Doligez-Leroy-Gonthier collector;the collector does not stop any mutator thread nor does itforce them to synchronize globally.The only critical sections between a mutator and the collector arethe code to enqueue/dequeue a 32 kB allocation segment to/from a globalsegment list and the write barrier code to push an object pointer ontothe collector's stack.Most of these data structures can be implemented in standardlock-free data structures.This achieves both efficient allocation and unobtrusive collectionin a multicore system.The proposed method has been implemented in SML#, afull-scale Standard ML compiler supporting multiple native threads onmulticore CPUs.Our benchmark tests show a drastically short pause timewith reasonably low overhead compared to the sequential bitmap-markingcollector.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Katsuhiro</first_name>
          <last_name>Ueno</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/katsuhiroueno/26e33bd1-fd8a-4eab-9ad6-ff2ad45cbe8e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Ohori</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d2492e20-b320-4326-99b1-96009f7d653c</subevent_id>
    <title>Haskell: Testing</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/haskellsymp-2016-papers</url>
    <url_link_display>Haskell</url_link_display>
    <tracks>
      <track>Haskell</track>
    </tracks>
    <timeslot>
      <slot_id>283accff-dafd-470d-81ec-f82d3edd3e4c</slot_id>
      <title>Welcome</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>09:15</start_time>
      <end_time>09:25</end_time>
      <description>undefined</description>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7e64d1ae-2db1-40d0-9a2d-16032e0d03e2</slot_id>
      <title>FitSpec: Refining Property Sets for Functional Testing</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>09:25</start_time>
      <end_time>09:50</end_time>
      <description>This paper presents FitSpec, a tool providing automated assistance in the task of refining sets of test properties for Haskell functions. FitSpec tests mutant variations of functions under test against a given property set, recording any surviving mutants that pass all tests. The number of survivingmutants and any smallest survivor are presented to the user. A surviving mutant indicates incompleteness of the property set, prompting the user to amend a property or to add a new one, making the property set stronger. Based on the same test results, FitSpec also provides conjectures in the form of equivalences and implications between property subsets. These conjectures help the user to identify minimal core subsets of properties and so to reduce the cost of future property-based testing.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rudy</first_name>
          <last_name>Braquehais</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Colin</first_name>
          <last_name>Runciman</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bbc8b27e-7e7f-4cab-87e9-bfbc8f3861f1</slot_id>
      <title>QuickFuzz: An Automatic Random Fuzzer for Common File Formats</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>09:50</start_time>
      <end_time>10:15</end_time>
      <description>Fuzzing is a technique that involves testing programs using invalidor erroneous inputs. Most fuzzers require a set of valid inputs as astarting point, in which mutations are then introduced. QuickFuzz is afuzzer that leverages QuickCheck-style random test-case generationto automatically test programs that manipulate common file formatsby fuzzing. We rely on existing Haskell implementations offile-format-handling libraries found on Hackage, thecommunity-driven Haskell code repository. We have tried QuickFuzzin the wild and found that the approach is effective indiscovering vulnerabilities in real-world implementations of browsers,image processing utilities and file compressors among others.In addition, we introduce a mechanism to automatically derive random generators for the typesrepresenting these formats. QuickFuzz handles most well-known imageand media formats, and can be used to test programs and librarieswritten in any language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Grieco</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martín</first_name>
          <last_name>Ceresa</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pablo</first_name>
          <last_name>Buiras</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~buiras/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2b0c2eee-3b98-45e4-b367-9d04f3a69fe5</subevent_id>
    <title>Haskell: Lightning Talks</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/haskellsymp-2016-papers</url>
    <url_link_display>Haskell</url_link_display>
    <tracks>
      <track>Haskell</track>
    </tracks>
    <timeslot>
      <slot_id>60b5a038-db5b-4e17-8b63-9747ddb596d7</slot_id>
      <title>Lightning Talks</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>16:40</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ce100be0-1a29-4e11-854c-17c8668b0fd1</subevent_id>
    <title>Haskell: PC Chair Report and State of Haskell</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/haskellsymp-2016-papers</url>
    <url_link_display>Haskell</url_link_display>
    <tracks>
      <track>Haskell</track>
    </tracks>
    <timeslot>
      <slot_id>6a8440ec-9709-4e8c-a81e-597b85f7abce</slot_id>
      <title>PC Chair Report and State of Haskell</title>
      <room>Noh Theater</room>
      <date>2016/09/23</date>
      <start_time>11:45</start_time>
      <end_time>12:35</end_time>
      <description>undefined</description>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1176adf9-5ea1-474e-ba6f-dfe8a467582c</subevent_id>
    <title>Research Papers: Session 8</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/20</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>7988e5fd-3301-4adf-bef0-37e3b1abf7f7</slot_id>
      <title>An Abstract Memory Functor for Verified C Static Analyzers</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>17:15</start_time>
      <end_time>17:40</end_time>
      <description>Abstract interpretation provides advanced techniques to infer numerical invariants on programs. There is an abundant literature about numerical abstract domains that operate on scalar variables. This work deals with lifting these techniques to a realistic C memory model. We present an abstract memory functor that takes as argument any standard numerical abstract domain, and builds a memory abstract domain that finely tracks properties about memory contents, taking into account union types, pointer arithmetic and type casts. This functor is implemented and verified inside the Coq proof assistant with respect to the CompCert compiler memory model. Using the Coq extraction mechanism, it is fully executable and used by the Verasco C static analyzer.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sandrine</first_name>
          <last_name>Blazy</last_name>
          <affiliation>University of Rennes 1, France</affiliation>
          <bio>I am professor in the computer science department of the University of Rennes 1, where I am in charge of the research master in computer science. I am a member of CELTIQUE, a joint project-team with Inria Rennes Bretagne Atlantique and the IRISA laboratory. 
My research activities concern the formal verification using the Coq proof assistant of program transformations and semantic properties of programming languages, such as those found in the CompCert compiler and the Verasco static analyzer. I teach mechanized semantics (in Coq), functional programming (in OCaml), formal methods (using the Why3 tool), and software vulnerabilities.</bio>
          <homepage_url>http://www.irisa.fr/celtique/blazy/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/sandrineblazy/bacd0031-1d22-476c-b6e5-fc58b1ab1177/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vincent</first_name>
          <last_name>Laporte</last_name>
          <affiliation>IMDEA Software Institute, Spain</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Pichardie</last_name>
          <affiliation>ENS Rennes, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/celtique/pichardie/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/davidpichardie/b0f30e9b-c1d3-4e4f-9923-4cf150989f86/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e6d44a56-8a1c-443a-b482-7ad022a643d3</slot_id>
      <title>Constructive Galois Connections: Taming the Galois Connection Framework for Mechanized Metatheory</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>16:50</start_time>
      <end_time>17:15</end_time>
      <description>Galois connections are a foundational tool for structuring abstraction insemantics and their use lies at the heart of the theory of abstractinterpretation. Yet, mechanization of Galois connections remains limited torestricted modes of use, preventing their general application in mechanizedmetatheory and certified programming. 
This paper presents constructive Galois connections, a variant of Galoisconnections that is effective both on paper and in proof assistants; iscomplete with respect to a large subset of classical Galois connections; andenables more general reasoning principles, including the &amp;quot;calculational&amp;quot; styleadvocated by Cousot. 
To design constructive Galois connection we identify a restricted mode of useof classical ones which is both general and amenable to mechanization independently-typed functional programming languages. Crucial to our metatheoryis the addition of monadic structure to Galois connections to control a&amp;quot;specification effect&amp;quot;. Effectful calculations may reason classically, whilepure calculations have extractable computational content. Explicitly movingbetween the worlds of specification and implementation is enabled by ourmetatheory. 
To validate our approach, we provide two case studies in mechanizing existingproofs from the literature: one uses calculational abstract interpretation todesign a static analyzer, the other forms a semantic basis for gradual typing.Both mechanized proofs closely follow their original paper-and-pencilcounterparts, employ reasoning principles not captured by previousmechanization approaches, support the extraction of verified algorithms, andare novel.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Darais</last_name>
          <affiliation>University of Maryland, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://david.darais.com</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/daviddarais/84b89731-ca3c-4d97-9540-4ce4db09d1d1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Van Horn</last_name>
          <affiliation>University of Maryland, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.umd.edu/~dvanhorn/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/davidvanhorn/767593d7-5911-4b7b-8895-518920ea97a7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dde02b97-e836-4155-a430-e36e22360247</subevent_id>
    <title>Research Papers: Session 2</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/19</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>8a034e9c-2b10-4e76-8b37-a3c620f75456</slot_id>
      <title>Refinement through Restraint: Bringing Down the Cost of Verification</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>14:30</start_time>
      <end_time>14:55</end_time>
      <description>We present a framework aimed at significantly reducing the cost of verifying certain classes of systems software, such as file systems. Our framework allows for equational reasoning about systems code written in our new language, Cogent. Cogent is a restricted, polymorphic, higher-order, and purely functional language with linear types and without the need for a trusted runtime or garbage collector. Linear types allow us to assign two semantics to the language: one imperative, suitable for efficient C code generation; and one functional, suitable for equational reasoning and verification. As Cogent is a restricted language, it is designed to easily interoperate with existing C functions and to connect to existing C verification frameworks. Our framework is based on certifying compilation: For a well-typed Cogent program, our compiler produces C code, a high-level shallow embedding of its semantics in Isabelle/HOL, and a proof that the C code correctly refines this embedding. Thus one can reason about the full semantics of real-world systems code productively and equationally, while retaining the interoperability and leanness of C. The compiler certificate is a series of language-level proofs and per-program translation validation phases, combined into one coherent top-level theorem in Isabelle/HOL.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Liam</first_name>
          <last_name>O'Connor</last_name>
          <affiliation>UNSW, Australia</affiliation>
          <bio>Liam is a PhD student at UNSW Australia working on Trustworthy Systems projects with Data61 at CSIRO (formerly known as NICTA). His PhD work focuses on the use of linear typed languages to provide easy-to-reason-about semantics for formal verification of operating system components. More broadly, his research interests include automated proof and reasoning, particularly in the context of dependently typed programming languages, type inference, static analysis, and concurrency.</bio>
          <homepage_url>http://liamoc.net</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/liamoconnor/62bc9dba-ffaf-41b7-94db-85d112d608ea/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zilin</first_name>
          <last_name>Chen</last_name>
          <affiliation>UNSW, Australia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christine</first_name>
          <last_name>Rizkallah</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.mpi-inf.mpg.de/~crizkall/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sidney</first_name>
          <last_name>Amani</last_name>
          <affiliation>UNSW, Australia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Japheth</first_name>
          <last_name>Lim</last_name>
          <affiliation>Data61, Australia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Toby</first_name>
          <last_name>Murray</last_name>
          <affiliation>University of Melbourne, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.eng.unimelb.edu.au/tobym</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/tobymurray/b22e1351-c7fc-420a-acef-492aadfce115/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Yutaka</first_name>
          <last_name>Nagashima</last_name>
          <affiliation>Data61, Australia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Sewell</last_name>
          <affiliation>UNSW, Australia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Gerwin</first_name>
          <last_name>Klein</last_name>
          <affiliation>UNSW, Australia</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8ce2ab90-4b91-4bad-a71b-248e47f558dc</slot_id>
      <title>A New Verified Compiler Backend for CakeML</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>13:40</start_time>
      <end_time>14:05</end_time>
      <description>We have developed and mechanically verified a new compiler backend for CakeML. Our new compiler features a sequence of intermediate languages that allows it to incrementally compile away high-level features and enables verification at the right levels of semantic detail. In this way, it resembles mainstream (unverified) compilers for strict functional languages. The compiler supports efficient curried multi-argument functions, configurable data representations, exceptions that unwind the call stack, register allocation, and more. The compiler targets several architectures: x86-64, ARMv6, ARMv8, MIPS-64, and RISC-V. 
In this paper, we present the overall structure of the compiler, including its 12 intermediate languages, and explain how everything fits together. We focus particularly on the interaction between the verification of the register allocator and the garbage collector, and memory representations. The entire development has been carried out within the HOL4 theorem prover.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yong Kiam</first_name>
          <last_name>Tan</last_name>
          <affiliation>IHPC at A*STAR, Singapore</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Magnus O.</first_name>
          <last_name>Myreen</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ramana</first_name>
          <last_name>Kumar</last_name>
          <affiliation>Data61 at CSIRO, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cl.cam.ac.uk/~rk436/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/ramanakumar/d929d436-8b41-4a14-b544-c55f5890380f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anthony</first_name>
          <last_name>Fox</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Scott</first_name>
          <last_name>Owens</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~so294/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/scottowens/8ea3498a-d167-4417-a1c8-bb0e57a23b5e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Michael</first_name>
          <last_name>Norrish</last_name>
          <affiliation>Data61 at CSIRO, Australia</affiliation>
          <bio>I did my PhD at the University of Cambridge, finishing in 1999. Since 2003, I have worked in Canberra, first with NICTA, and now with Data61 (the result of NICTA merging into CSIRO)</bio>
          <homepage_url>http://ts.data61.csiro.au/people/?cn=Michael+Norrish</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/michaelnorrish/b4ee437b-353d-4dc9-8d90-ed1f71465fe6/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>947b3bdd-9f45-4a67-aa47-e9add71e5565</slot_id>
      <title>Sequent Calculus as a Compiler Intermediate Language</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>14:05</start_time>
      <end_time>14:30</end_time>
      <description>The λ-calculus is popular as an intermediate language for practical compilers. But in the world of logic it has a lesser-known twin, born at the same time, called the sequent calculus. Perhaps that would make for a good intermediate language, too? To explore this question we designed Sequent Core, a practically-oriented core calculus based on the sequent calculus, and used it to re-implement a substantial chunk of the Glasgow Haskell Compiler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paul</first_name>
          <last_name>Downen</last_name>
          <affiliation>University of Oregon, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Luke</first_name>
          <last_name>Maurer</last_name>
          <affiliation>University of Oregon, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zena M.</first_name>
          <last_name>Ariola</last_name>
          <affiliation>University of Oregon, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Simon</first_name>
          <last_name>Peyton Jones</last_name>
          <affiliation>Microsoft Research, UK</affiliation>
          <bio>Simon Peyton Jones, MA, MBCS, CEng, graduated from Trinity College Cambridge in 1980. After two years in industry, he spent seven years as a lecturer at University College London, and nine years as a professor at Glasgow University, before moving to Microsoft Research (Cambridge) in 1998. His main research interest is in functional programming languages, their implementation, and their application. He has led a succession of research projects focused around the design and implementation of production-quality functional-language systems for both uniprocessors and parallel machines. He was a key contributor to the design of the now-standard functional language Haskell, and is the lead designer of the widely-used Glasgow Haskell Compiler (GHC). He has written two textbooks about the implementation of functional languages.
More generally, he is interested in language design, rich type systems, software component architectures, compiler technology, code generation, runtime systems, virtual machines, and garbage collection. He is particularly motivated by direct use of principled theory to practical language design and implementation – that’s one reason he loves functional programming so much.</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/simonpaytonjones/6128a22a-7036-4d52-90ac-2b1b5be66354/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0bf4a8bd-725f-4634-85eb-9266b4653b23</subevent_id>
    <title>Haskell: Strictness and STM </title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/23</date>
    <url>http://conf.researchr.org/track/icfp-2016/haskellsymp-2016-papers</url>
    <url_link_display>Haskell</url_link_display>
    <tracks>
      <track>Haskell</track>
    </tracks>
    <timeslot>
      <slot_id>0bc12121-190c-4f69-aef7-74587b657dd5</slot_id>
      <title>Autobahn: Using Genetic Algorithms to Infer Strictness Annotations</title>
      <room>Noh Theater</room>
      <date>2016/09/23</date>
      <start_time>09:50</start_time>
      <end_time>10:15</end_time>
      <description>Although laziness enables beautiful code, it comes with non-trivial performance costs. The ghc compiler for Haskell has optimizations to reduce those costs, but the optimizations are not sufficient. As a result, Haskell also provides a variety of strictness annotations so that users can indicate program points where an expression should be evaluated eagerly. Skillful use of those annotations is a black art, known only to expert Haskell programmers. In this paper, we introduce AUTOBAHN, a tool that uses genetic algorithms to automatically infer strictness annotations that improve program performance on representative inputs. Users examine the suggested annotations for soundness and can instruct AUTOBAHN to automatically produce modified sources. Experiments on 60 programs from the NoFib benchmark suite show that AUTOBAHN can infer annotation sets that improve runtime performance by a geometric mean of 8.5%. Case studies show AUTOBAHN can reduce the live size of a GC simulator by 99% and infer application-specific annotations for Aeson library code. A 10-fold cross-validation study shows the AUTOBAHN -optimized GC simulator generally outperforms a version optimized by an expert.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yisu Remy</first_name>
          <last_name>Wang</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Diogenes</first_name>
          <last_name>Nunez</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kathleen</first_name>
          <last_name>Fisher</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>Kathleen Fisher is Professor in the Computer Science Department at Tufts. Previously, she was a Principal Member of the Technical Staff at AT&amp;amp;T Labs Research, a Consulting Faculty Member in the Computer Science Department at Stanford University, and a program manager at DARPA where she started and managed the HACMS and PPAML programs. Kathleen’s research focuses on advancing the theory and practice of programming languages and on applying ideas from the programming language community to the problem of ad hoc data management. The main thrust of her work has been in domain-specific languages to facilitate programming with massive amounts of ad hoc data, including the Hancock system for efficiently building signatures from massive transaction streams and the PADS system for managing ad hoc data. Recently, she has been exploring synergies between machine learning and programming languages and studying how to apply advances in programming languages to the problem of building more secure systems.
Kathleen is an ACM Fellow. She has served as program chair for FOOL, ICFP, CUFP, and OOPSLA and as General Chair for ICFP 2015. Kathleen is past Chair of the ACM Special Interest Group in Programming Languages (SIGPLAN), past Co-Chair of CRA’s Committee on the Status of Women (CRA-W), and a former editor of the Journal of Functional Programming. She is an Associate Editor for TOPLAS.</bio>
          <homepage_url>http://www.cs.tufts.edu/~kfisher</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/kathleenfisher/04a1b289-f7fe-4e91-b686-6b34a7a45cb2/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>98fcf9dd-9ac3-407f-91bc-df003719ee92</slot_id>
      <title>Revisiting Software Transactional Memory in Haskell</title>
      <room>Noh Theater</room>
      <date>2016/09/23</date>
      <start_time>09:25</start_time>
      <end_time>09:50</end_time>
      <description>Software Transactional Memory (STM) has become very popular in Haskell. Currently, there are nearly 500 packages on Haskell's package archive that directly use STM\@. Despite the widespread use in real world applications, Haskell's STM implementation has seen very few updates since its introduction in 2005. 
In this work, we describe our efforts to redesign the STM implementation in the Glasgow Haskell Compiler (GHC), based on a TL2-like implementation that is able to support both \verb|orElse| and \verb|retry| without the use of traditional nested transactions. We argue that our implementation is simpler than the current GHC implementation while supporting opacity. We also demonstrate that our implementation performs better than the current GHC implementation on a number of benchmarks by multiple orders of magnitude for long-running transactions. 
In an effort to measure the performance of \verb|orElse| and \verb|retry|, we present an STM-based work stealing scheduler. With \verb|orElse| and \verb|retry|, we are able to elegantly implement the scheduler in just a few lines of code. We have modified the Par Monad, a real-world Haskell package that provides deterministic parallelism, to use our STM-based work stealing scheduler and show that it is not only simpler but is able to perform as well as the current scheduler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Le</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Yates</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Fluet</last_name>
          <affiliation>Rochester Institute of Technology</affiliation>
          <bio>I was a Research Assistant Professor with the Toyota Technological Institute at Chicago from September 2006 to June 2009.
I graduated with a Ph.D. in computer science from Cornell University in January 2007. My advisor was Greg Morrisett.
I graduated with a B.S. in mathematics from Harvey Mudd College in 1999. My advisor was Arthur Benjamin.</bio>
          <homepage_url>http://www.cs.rit.edu/~mtf</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/matthewfluet/10905b92-706f-468a-82c6-cb8130537f56/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b1036b82-5c95-429e-9c40-3db5b00e45de</subevent_id>
    <title>Research Papers: Session 5</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/20</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>590d0f88-90da-4f33-869d-7cdbfaddb0ba</slot_id>
      <title>Think Like a Vertex, Behave Like a Function! A Functional DSL for Vertex-Centric Big Graph Processing</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>11:25</start_time>
      <end_time>11:50</end_time>
      <description>The vertex-centric programming model, known as “think like avertex”, is being used more and more to support various big graphprocessing methods through iterative supersteps that execute inparallel a user-defined vertex program over each vertex of a graph.However, the imperative and message-passing style of existing systemsmakes defining a vertex program unintuitive. In this paper, we showthat one can benefit more from “Thinking like a vertex” by“Behaving like a function” rather than “Acting like a procedure”with full use of side effects and explicit control of message passing,state, and termination. We propose a functional approach tovertex-centric graph processing in which the computation at everyvertex is abstracted as a higher-order function and present Fregel, anew domain-specific language. Fregel has clear functional semantics,supports declarative description of vertex computation, and can beautomatically translated into Pregel, an emerging imperative-styledistributed graph processing framework, and thereby achieve promisingperformance. Experimental results for several typical examples showthe promise of this functional approach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kento</first_name>
          <last_name>Emoto</last_name>
          <affiliation>Kyushu Institute of Technology, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ipl-lab.org/~emoto/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/kentoemoto/b34f755c-18e4-4a0d-89a3-f7b10b0ff331/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kiminori</first_name>
          <last_name>Matsuzaki</last_name>
          <affiliation>Kochi University of Technology, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.info.kochi-tech.ac.jp/~kmatsu/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>National Institute of Informatics, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.nii.ac.jp/~hu/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/zhenjianghu/1d3515c4-02fb-406d-9f35-42b5e4d949bf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Akimasa</first_name>
          <last_name>Morihata</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.graco.c.u-tokyo.ac.jp/labs/morihata/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/akimasamorihata/c0883451-c2d1-42da-8e5d-d6e6699b8c8e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hideya</first_name>
          <last_name>Iwasaki</last_name>
          <affiliation>University of Electro-Communications, Japan</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>60489281-d8c6-4b26-9964-86998e7b8a99</slot_id>
      <title>A Glimpse of Hopjs</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>10:35</start_time>
      <end_time>11:00</end_time>
      <description>Hop.js is a multitier programming environment for JavaScript. Itallows a single JavaScript program to describe the client-side and theserver-side components of a web application. Its runtime environmentensures consistent executions of the application on the server and onthe client. 
This paper overviews the Hop.js design. It shows the JavaScriptextensions that makes it possible to conceive web applicationsglobally. It presents how Hop.js interacts with the outside world. Italso briefly presents the Hop.js implementation. It presents theHop.js web server implementation, the handling of server-sideparallelism, and the JavaScript and HTML compilers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Serrano</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-sop.inria.fr/members/Manuel.Serrano/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vincent</first_name>
          <last_name>Prunet</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ba02c803-e3fb-44d2-b4b0-678f0cd8c38e</slot_id>
      <title>Experience Report: Growing and Shrinking Polygons for Random Testing of Computational Geometry Algorithms</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>11:00</start_time>
      <end_time>11:25</end_time>
      <description>This paper documents our experience of adapting and using the QuickCheck-style approach for extensive randomised property-based testing of computational geometry algorithms. 
The need in rigorous evaluation of computational geometry procedures has naturally arisen in our quest of organising a medium-size programming contest for second year university students—an experiment we conducted as an attempt to introduce them to computational geometry. The main effort in organising the event was implementation of a solid infrastructure for testing and ranking solutions. For this, we employed functional programming techniques. The choice of the language and the paradigm made it possible for us to engineer, from scratch and in a very short period of time, a series of robust geometric primitives and algorithms, as well as implement a scalable framework for their randomised testing. 
We describe the main insights, enabling efficient random testing of geometric procedures, and report on our experience of using the testing framework, which helped us to detect and fix a number of issues not just in our programming artefacts, but also in the published algorithms we had implemented.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ilya</first_name>
          <last_name>Sergey</last_name>
          <affiliation>University College London, UK</affiliation>
          <bio>I am a lecturer (assistant professor) at University College London.
Prior to joining UCL, I was a postdoctoral researcher at IMDEA Software Institute (Madrid, Spain). I defended my PhD in 2012 in the DistriNet research group at the Department of Computer Sciences of KU Leuven (Belgium). Before that I received my MSc degree in Mathematics and Computer Science from Saint Petersburg State University (Russia) in 2008.
My research interests dwell in the area of the design and implementation of programming languages, including but not limited to program semantics, certified programming, concurrency and abstract interpretation. I am particularly interested in developing verification techniques and static analyses for higher-order and concurrent programs.</bio>
          <homepage_url>http://ilyasergey.net</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/ilyasergey/b2941c89-4843-4194-852a-81c8a30814fa/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bca06770-e0d4-448b-b5df-06967ae5df3b</slot_id>
      <title>Datafun: A Functional Datalog</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>11:50</start_time>
      <end_time>12:15</end_time>
      <description>Datalog may be considered either an unusually powerful query language or acarefully limited logic programming language. Datalog is declarative,expressive, and optimizable, and has been applied successfully in a widevariety of problem domains. However, most use-cases require extending Datalogin an application-specific manner. In this paper we define Datafun, ananalogue of Datalog supporting higher-order functional programming. The keyidea is to track monotonicity with types.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Arntzenius</last_name>
          <affiliation>University of Birmingham, UK</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neelakantan R.</first_name>
          <last_name>Krishnaswami</last_name>
          <affiliation>University of Birmingham, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mpi-sws.org/~neelk/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/neelakantankrishnaswami/61a5e7f5-2edd-4b98-ad13-3295b01601ca/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>feb5f8e8-4493-41df-8239-5529cf83335e</subevent_id>
    <title>Haskell: Functors</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/haskellsymp-2016-papers</url>
    <url_link_display>Haskell</url_link_display>
    <tracks>
      <track>Haskell</track>
    </tracks>
    <timeslot>
      <slot_id>f180357d-443f-43e1-a073-3a81d8ad2b15</slot_id>
      <title>How to Twist Pointers without Breaking Them</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>12:10</start_time>
      <end_time>12:35</end_time>
      <description>Using the theory of monoids and monoid actions, we give a unified framework that handles three common pointer manipulation tasks, namely, data serialisation, deserialisation, and memory allocation. Our main theoretical contribution is the formulation of the notion of a \emph{twisted functor}, a generalisation of the semi-direct product construction for monoids. We show that semi-direct products and twisted functors are particularly well suited as an abstraction for many pointer manipulation tasks. 
We describe the implementation of these abstractions in the context of a cryptographic library for Haskell. Twisted functors allow us to abstract all pointer arithmetic and size calculations into a few lines of code, significantly reducing the opportunities for buffer overflows.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Satvik</first_name>
          <last_name>Chauhan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Piyush</first_name>
          <last_name>Kurur</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brent</first_name>
          <last_name>Yorgey</last_name>
          <affiliation>Hendrix College</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ozark.hendrix.edu/~yorgey/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/brentyorgey/f4238cb4-a860-4baf-9f38-14aa0fe3ee75/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f5d68591-2d43-485a-b358-2dad4302754a</slot_id>
      <title>Free Delivery (Functional Pearl)</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>Remote procedure calls are computationally expensive, because network round-trips take several orders of magnitude longer than local interactions. One common technique for amortizing this cost is to batch together multiple independent requests into one compound request. Batching requests amounts to serializing the abstract syntax tree of a small program, in order to transmit it and run it remotely. The standard representation for abstract syntax is to use free monads; we show that free applicative functors are actually a better choice of representation for this scenario.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Gibbons</last_name>
          <affiliation>University of Oxford, UK</affiliation>
          <bio>I am Director of the Software Engineering Programme, which offers part-time professional Masters’ degrees in Software Engineering and in Software and Systems Security. I am currently the Chair of Faculty of Computer Science. For the academic years 2008-2010 was also Deputy Director of the Computing Laboratory (now the Department of Computer Science). I am a fellow of Kellogg College. Before taking up this post in 1999, I held lectureships at Oxford Brookes University and the University of Auckland, New Zealand.</bio>
          <homepage_url>http://www.cs.ox.ac.uk/jeremy.gibbons/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/jeremygibbons/e4e44a9a-31d8-4104-abdc-4a28ecbd8618/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>46435b88-1e51-40b9-a97c-254546de65bc</subevent_id>
    <title>Haskell: FRP</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/haskellsymp-2016-papers</url>
    <url_link_display>Haskell</url_link_display>
    <tracks>
      <track>Haskell</track>
    </tracks>
    <timeslot>
      <slot_id>b448d6d1-ccee-47bd-8275-090490b92e22</slot_id>
      <title>Functional Reactive Programming, Refactored</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>11:00</start_time>
      <end_time>11:25</end_time>
      <description>Functional Reactive Programming (FRP) has come to mean many things. Yet, scratch the surface of the multitude of realisations, and there is great commonality between them. This paper investigates this commonality, turning it into a mathematically coherent and practical FRP realisation that allows us to express the functionality of many existing FRP systems and beyond by providing a minimal FRP core parameterised on a monad. We give proofs for our theoretical claims and we have verified the practical side by benchmarking a set of existing, non-trivial Yampa applications running on top of our new system with very good results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Perez</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Barenz</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Henrik</first_name>
          <last_name>Nilsson</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e8ebc54a-8c3a-4190-8c80-8990ccd20e60</slot_id>
      <title>Causal Commutative Arrows Revisited</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>10:35</start_time>
      <end_time>11:00</end_time>
      <description>Causal commutative arrows (CCA) extend arrows with additional constructs and laws that make them suitable for modelling domains such as functional reactive programming, differential equations and synchronous dataflow. 
Earlier work has revealed that a syntactic transformation of CCA computations into normal form can result in significant performance improvements, sometimes increasing the speed of programs by orders of magnitude. 
In this work we reformulate the normalization as a type class instance and derive optimized observation functions via a specialization to stream transformers to demonstrate that the same dramatic improvements can be achieved without leaving the language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Yallop</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~jdy22/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hai</first_name>
          <last_name>Liu</last_name>
          <affiliation>Intel Labs</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>abc3245e-0c02-4932-8e0d-83d6e21df813</subevent_id>
    <title>Haskell: Web Technology</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/haskellsymp-2016-papers</url>
    <url_link_display>Haskell</url_link_display>
    <tracks>
      <track>Haskell</track>
    </tracks>
    <timeslot>
      <slot_id>787c5480-58de-4c5c-b200-da8477c913fe</slot_id>
      <title>Experience Report: Developing High Performance HTTP/2 Server in Haskell</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>While the speed of the Internet has been increasing,HTTP/1.1 has been plagued byhead-of-line blocking, low concurrency and redundant headers.To solve these problems, HTTP/2 was standardized.This paper summarizes our experience implementing HTTP/2 in Haskell.We found several techniques to improve the performance ofthe header compressionand identified a suitable data structure for HTTP/2 priority.Also, we showed that Haskell lightweight threadsare useful for HTTP/2 wherethe common tactics of one lightweight thread per connection cannot be used.The HTTP/2 implementation of Warp,the popular HTTP server library in Haskell,ultimately provides better throughput than its HTTP/1.1 counterpart.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kazuhiko</first_name>
          <last_name>Yamamoto</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>df7f820b-8840-4edd-84c0-a38150a28b66</slot_id>
      <title>High-Performance Client-Side Web Applications through Haskell EDSLs</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>We present Aplite, a domain-specific language embedded in Haskell for implementing performance-critical functions in client-side web applications. In Aplite, we apply partial evaluation, multi-stage programming and techniques adapted from machine code-targeting, high-performance EDSLs to the domain of web applications. We use Aplite to implement, among other benchmarks, procedural animation using Perlin noise, symmetrical encryption and K-means clustering, showing Aplite to be consistently faster than equivalent hand-written JavaScript – up to an order of magnitude for some benchmarks. We also demonstrate how Aplite's multi-staged nature can be used to automatically tune programs to the environment in which they are running, as well as to inputs representative of the programs' intended workload. 
High-performance computation in the web browser is an attractive goal for many reasons: interactive simulations and games, cryptographic applications and reducing web companies' electricity bills by outsourcing expensive computations to users' web browsers. Similarly, functional programming in the browser is attractive due to its promises of simpler, shorter, safer programs. In this paper, we propose a way to combine the two.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anton</first_name>
          <last_name>Ekblad</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ea105db6-8ff7-4ac7-a23a-4163a513f5f2</subevent_id>
    <title>Research Papers: Session 9</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/21</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>ca8bf74d-0da4-4dfd-a378-dff0d10f0963</slot_id>
      <title>Disjoint Intersection Types</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>11:25</start_time>
      <end_time>11:50</end_time>
      <description>Dunfield showed that a simply typed core calculus with intersectiontypes and a merge operator is able to capture various programminglanguage features. While his calculus is type-safe, it is notcoherent: different derivations for the same expression canelaborate to expressions that evaluate to different values.The lack of coherence is an importantdisadvantage for adoption of his core calculus in implementations ofprogramming languages, as the semantics of the programming languagebecomes implementation-dependent. 
This paper presents λi: a coherent and type-safe calculus with aform of *intersection types and a merge operator.Coherence is achieved by ensuring that intersection typesare disjoint and programs are sufficientlyannotated to avoid type ambiguity. We propose a definition of disjointness where twotypes A and B are disjoint only if certain set of types are commonsupertypes of A and B. We investigate three different variants of λi, with three variants of disjointness. In the simplestvariant, which does not allow top types, two types are disjoint ifthey do not share any common supertypes at all. The other two variantsintroduce top types and refine the notion of disjointness to allowtwo types to be disjoint when the only the set of common supertypes aretop-like. The difference between the two variants with toptypes is on the definition of top-like types, which has an impact onwhich types are allowed on intersections. We present a type systemthat prevents intersection types that are not disjoint, as well as analgorithmic specifications to determine whether two types are disjointfor all three variants.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bruno C. d. S.</first_name>
          <last_name>Oliveira</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.hku.hk/research/profile.jsp?teacher=bruno</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/brunooliveira/fec3698f-899c-4d10-ba39-bcd0d777191c/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhiyuan</first_name>
          <last_name>Shi</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>João</first_name>
          <last_name>Alpuim</last_name>
          <affiliation>University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>db16a379-d6d9-4823-8f20-c6d4ec3fe5f0</slot_id>
      <title>Set-Theoretic Types for Polymorphic Variants</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>11:50</start_time>
      <end_time>12:15</end_time>
      <description>Polymorphic variants are a useful feature of the OCaml language whosecurrent definition and implementation rely on kinding constraints tosimulate a subtyping relation via unification. This yields an awkwardformalization and results in a type system whose behaviour is in somecases unintuitive and/or unduly restrictive. 
In this work, we present an alternative formalization of polymorphicvariants, based on set-theoretic types and subtyping, that yieldsa cleaner and more streamlined system. Our formalization is moreexpressive than the current one (it types more programs while preservingtype safety), it can internalize some meta-theoretic properties, and itremoves some pathological cases of the current implementation resultingin a more intuitive and, thus, predictable type system.More generally, this work shows how to add full-fledged union types tofunctional languages of the ML family that usually rely on theHindley-Milner type system. As an aside, our system also improvesthe theory of semantic subtyping, notably by proving completeness forthe type reconstruction algorithm.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Giuseppe</first_name>
          <last_name>Castagna</last_name>
          <affiliation>University of Paris Diderot, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irif.univ-paris-diderot.fr/~gc/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tommaso</first_name>
          <last_name>Petrucciani</last_name>
          <affiliation>University of Genoa, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dibris.unige.it/petrucciani-tommaso</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/tommasopetrucciani/757aad12-2deb-4368-8683-be668c4bc957/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kim</first_name>
          <last_name>Nguyễn</last_name>
          <affiliation>University of Paris-Sud, France</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e68d620a-98f7-4625-94ab-55b6f0d36cf5</slot_id>
      <title>Ghostbuster: A Tool for Simplifying and Converting GADTs</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>10:35</start_time>
      <end_time>11:00</end_time>
      <description>Generalized Algebraic Dataypes, or simply GADTs, can encode non-trivial properties in the types of the constructors. Once such properties are encoded in a datatype, however, all code manipulating that datatype must provide proof that it maintains these properties in order to typecheck. In this paper, we take a step towards gradualizing these obligations. We introduce a tool, Ghostbuster, that produces simplified versions of GADTs which elide selected type parameters, thereby weakening the guarantees of the simplified datatype in exchange for reducing the obligations necessary to manipulate it. Like ornaments, these simplified datatypes preserve the recursive structure of the original, but unlike ornaments we focus on information-preserving bidirectional transformations. Ghostbuster generates type-safe conversion functions between the original and simplified datatypes, which we prove are the identity function when composed. We evaluate a prototype tool for Haskell against thousands of GADTs found on the Hackage package database, generating simpler Haskell'98 datatypes and round-trip conversion functions between the two.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Trevor L.</first_name>
          <last_name>McDonell</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~tmcdonell</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Timothy A. K.</first_name>
          <last_name>Zakian</last_name>
          <affiliation>Oxford University, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/timothyzakian/aa4563c3-463e-48cf-a916-44417bb8625c/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Cimini</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ryan R.</first_name>
          <last_name>Newton</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.indiana.edu/~rrnewton/homepage.html</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/ryanrnewton/7bd51bcb-5e54-4397-9ea7-abc910cfb02a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ed4a4ede-dcc4-4d30-838f-b6eab2dee70b</slot_id>
      <title>Indexed Codata Types</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>11:00</start_time>
      <end_time>11:25</end_time>
      <description>Indexed data types allow us to specify and verify many interesting invariants about finite data in a general purpose programming language. In this paper we investigate the dual idea: indexed codata types, which allow us to describe data-dependencies about infinite data structures. Unlike finite data which is defined by constructors, we define infinite data by observations. Dual to pattern matching on indexed data which may refine the type indices, we define copattern matching on indexed codata where type indices guard observations we can make. 
Our key technical contributions are three-fold: first, we extend Levy's call-by-push value language with support for indexed (co)data and deep (co)pattern matching; second, we provide a clean foundation for dependent (co)pattern matching using equality constraints; third, we describe a small-step semantics using a continuation-based abstract machine, define coverage for indexed (co)patterns, and prove type safety. This is an important step towards building a foundation where (co)data type definitions and dependent types can coexist.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Thibodeau</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Cave</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brigitte</first_name>
          <last_name>Pientka</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>Brigitte Pientka is an Associate Professor in the School of Computer Science at McGill University, and leading the Computation and Logic group. She received her PhD from Carnegie Mellon University in 2003, and studied previously at the University of Edinburgh and Technical University of Darmstadt.</bio>
          <homepage_url>http://www.cs.mcgill.ca/~bpientka/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/brigittepientka/bfe09af5-4a41-4a4e-ac04-154edf90c7a6/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c954ac2e-5297-4540-9a63-b5a60a93c740</subevent_id>
    <title>Research Papers: Session 3</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/19</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>0ddffab1-2c8f-44b9-9221-946eb005bab0</slot_id>
      <title>Oh Lord, Please Don't Let Contracts Be Misunderstood (Functional Pearl)</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>15:40</start_time>
      <end_time>16:05</end_time>
      <description>Contracts feel misunderstood, especially those with a higher-order soul. While software engineers appreciate contracts as tools for articulating the interface between components, functional programmers desperately search for their types and meaning, completely forgetting about their pragmatics. 
This gem presents a novel analysis of contract systems. Applied to the higher-order kind, this analysis reveals their large and clearly unappreciated software engineering potential. Three sample applications illustrate where this kind of exploration may lead.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christos</first_name>
          <last_name>Dimoulas</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.seas.harvard.edu/~chrdimo/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Max</first_name>
          <last_name>New</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://maxsnew.github.io</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/maxnew/1032d55a-9db1-4f7d-bf53-3dd3e80cea6d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robby</first_name>
          <last_name>Findler</last_name>
          <affiliation>Northwestern University</affiliation>
          <bio>robby@eecs.northwestern.edu</bio>
          <homepage_url>http://www.eecs.northwestern.edu/~robby/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/robbyfindler/28e677e8-d52c-40d1-841d-4b2774afecd1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Felleisen</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/matthias/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/matthiasfelleisen/3781509a-02f7-4e22-822d-04481501e833/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6946a789-5fb9-4ee2-8d41-2f4b3ae015d2</slot_id>
      <title>Fully Abstract Compilation via Universal Embedding</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>15:15</start_time>
      <end_time>15:40</end_time>
      <description>A fully abstract compiler guarantees that two source components are observationally equivalent in the source language if and only if their translations are observationally equivalent in the target. Full abstraction implies the translation is secure: target-language attackers can make no more observations of a compiled component than a source-language attacker interacting with the original source component. Proving full abstraction for realistic compilers is challenging because realistic target languages contain features (such as control effects) unavailable in the source, while proofs of full abstraction require showing that every target context to which a compiled component may be linked can be back-translated to a behaviorally equivalent source context.
We prove the first full abstraction result for a translation whose target language contains exceptions, but the source does not. Our translation—specifically, closure conversion of simply typed λ-calculus with recursive types—uses types at the target level to ensure that a compiled component is never linked with attackers that have more distinguishing power than source-level attackers. We present a new back-translation technique based on a shallow embedding of the target language into the source language at a dynamic type. Then boundaries are inserted that mediate terms between the untyped embedding and the strongly-typed source. This technique allows back-translating non-terminating programs, target features that are untypeable in the source, and well-bracketed effects.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Max</first_name>
          <last_name>New</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://maxsnew.github.io</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/maxnew/1032d55a-9db1-4f7d-bf53-3dd3e80cea6d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>William J.</first_name>
          <last_name>Bowman</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>I am a fifth year Ph.D. student at Northeastern University where I study Computer Science (specifically, programming languages).
The promise of programming languages research has been to provide high-level languages in which programmers can easily write complex programs without worrying about speed or low-level machine details. I think we have failed. Languages that provide strong guarantees are bemoaned as too complicated, compilers ignore those high-level guarantees anyway, and the folklore persists that C is the only language useful for writing fast code.
I want to make programs easier to design, write, and understand. To that end, I work on verifying compilers. I am particularly interested in equivalence preserving (fully-abstract) compilers. I also dabble in dependent types and compiler design and implementation.</bio>
          <homepage_url>https://www.williamjbowman.com/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/williamjbowman/65b17dd6-298e-44ef-b32a-dc068c8c668b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Amal</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/amal/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/amalahmed/3b4031f8-79ed-4cc8-b63c-543ba6923acd/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ba7680bd-591d-4347-aef5-df7f6a79c6fe</slot_id>
      <title>A Type Theory for Incremental Computational Complexity with Control Flow Changes</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>16:05</start_time>
      <end_time>16:30</end_time>
      <description>Incremental computation aims to speed up re-runs of a program afterits inputs have been modified slightly. It works by recording a traceof the program's first run and propagating changes through the tracein incremental runs, trying to re-use as much of the original trace aspossible. The recent work CostIt is a type and effect system toestablish the time complexity of incremental runs of a program, as afunction of input changes. However, CostIt is limited in twoways. First, it prohibits input changes that influence controlflow. This makes it impossible to type programs that, for instance,branch on inputs that may change. Second, the soundness of CostItis proved relative to an abstract cost semantics, but it is unclearhow the semantics can be realized. 
In this paper, we address both these limitations. We present DuCostIt,a re-design of CostIt, that combines reasoning about costs ofchange propagation and costs of from-scratch evaluation. The latterlifts the restriction on control flow changes. To obtain the typesystem, we refine Flow Caml, a type system for information flowanalysis, with cost effects. Additionally, we inherit from CostItindex refinements to track data structure sizes and a co-monadictype. Using a combination of binary and unary step-indexed logicalrelations, we prove DuCostIt's cost analysis sound relative to notonly an abstract cost semantics, but also a concrete semantics, whichis obtained by translation to an ML-like language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ezgi</first_name>
          <last_name>Çiçek</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/ezgicicek/12d59906-480a-4b13-b5e7-85bb743ea9f0/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zoe</first_name>
          <last_name>Paraskevopoulou</last_name>
          <affiliation>Princeton University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zoep.github.io/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Deepak</first_name>
          <last_name>Garg</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~dg</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/deepakgarg/2a70fd29-76c7-4771-98ce-7d8c591f4e69/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6c0d1704-24e4-4f19-bba8-0218845d356e</subevent_id>
    <title>Haskell: Language Features</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/22</date>
    <url>http://conf.researchr.org/track/icfp-2016/haskellsymp-2016-papers</url>
    <url_link_display>Haskell</url_link_display>
    <tracks>
      <track>Haskell</track>
    </tracks>
    <timeslot>
      <slot_id>3681f542-98b5-4d43-ac5a-461f0c63548d</slot_id>
      <title>Desugaring Haskell's do-Notation into Applicative Operations</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>15:45</start_time>
      <end_time>16:10</end_time>
      <description>Monads have taken the world by storm, and are supported bydo-notation (at least in Haskell). Programmers are increasinglywaking up to the usefulness and ubiquity of Applicatives, but theyhave so far been hampered by the absence of supporting notation. Inthis paper we show how to re-use the very same do-notation to workfor Applicatives as well, providing efficiency benefits for some typesthat are both Monad and Applicative, and syntactic convenience forthose that are merely Applicative. The result is fully implementedas an optional extension in GHC, and is in use at Facebook to makeit easy to write highly-parallel queries in a distributed system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Marlow</last_name>
          <affiliation>Facebook</affiliation>
          <bio>Simon Marlow is a Software Engineer on Facebook’s Site Integrity Infrastructure team in London. He is working on Haxl, a Haskell-based domain-specific language that is used by the teams fighting spam and malware. Simon is a co-author of the Glasgow Haskell Compiler, author of the book “Parallel and Concurrent Programming in Haskell”, and has a string of research publications in functional programming, language design, compilers, and language implementation.</bio>
          <homepage_url>http://community.haskell.org/~simonmar/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/simonmarlow/d6f3111f-a2c1-4f7f-af4b-7744c18ea27e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Peyton Jones</last_name>
          <affiliation>Microsoft Research, UK</affiliation>
          <bio>Simon Peyton Jones, MA, MBCS, CEng, graduated from Trinity College Cambridge in 1980. After two years in industry, he spent seven years as a lecturer at University College London, and nine years as a professor at Glasgow University, before moving to Microsoft Research (Cambridge) in 1998. His main research interest is in functional programming languages, their implementation, and their application. He has led a succession of research projects focused around the design and implementation of production-quality functional-language systems for both uniprocessors and parallel machines. He was a key contributor to the design of the now-standard functional language Haskell, and is the lead designer of the widely-used Glasgow Haskell Compiler (GHC). He has written two textbooks about the implementation of functional languages.
More generally, he is interested in language design, rich type systems, software component architectures, compiler technology, code generation, runtime systems, virtual machines, and garbage collection. He is particularly motivated by direct use of principled theory to practical language design and implementation – that’s one reason he loves functional programming so much.</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/simonpaytonjones/6128a22a-7036-4d52-90ac-2b1b5be66354/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Edward</first_name>
          <last_name>Kmett</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andrey</first_name>
          <last_name>Mokhov</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e22cde87-f745-4ad3-a493-bf8500da7958</slot_id>
      <title>Pattern Synonyms</title>
      <room>Noh Theater</room>
      <date>2016/09/22</date>
      <start_time>15:20</start_time>
      <end_time>15:45</end_time>
      <description>Pattern matching has proven to be a convenient, expressive way of inspecting data. Yet this language feature, in its traditional form, is limited: patterns must be data constructors of concrete data types. No computation or abstraction is allowed. The data type in question must be concrete, with no ability to enforce any invariants. Any change in this data type requires all clients to update their code. 
This paper introduces pattern synonyms, which allow programmers to abstract over patterns, painting over all the shortcomings listed above. Pattern synonyms are assigned types, enabling a compiler to check the validity of a synonym independent of its definition. These types are intricate; detailing how to assign a type to a pattern synonym is a key contribution of this work. We have implemented pattern synonyms in the Glasgow Haskell Compiler, where they have enjoyed immediate popularity, but we believe this feature could easily be exported to other languages that support pattern matching.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Pickering</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Gergo</first_name>
          <last_name>Erdi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Simon</first_name>
          <last_name>Peyton Jones</last_name>
          <affiliation>Microsoft Research, UK</affiliation>
          <bio>Simon Peyton Jones, MA, MBCS, CEng, graduated from Trinity College Cambridge in 1980. After two years in industry, he spent seven years as a lecturer at University College London, and nine years as a professor at Glasgow University, before moving to Microsoft Research (Cambridge) in 1998. His main research interest is in functional programming languages, their implementation, and their application. He has led a succession of research projects focused around the design and implementation of production-quality functional-language systems for both uniprocessors and parallel machines. He was a key contributor to the design of the now-standard functional language Haskell, and is the lead designer of the widely-used Glasgow Haskell Compiler (GHC). He has written two textbooks about the implementation of functional languages.
More generally, he is interested in language design, rich type systems, software component architectures, compiler technology, code generation, runtime systems, virtual machines, and garbage collection. He is particularly motivated by direct use of principled theory to practical language design and implementation – that’s one reason he loves functional programming so much.</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/simonpaytonjones/6128a22a-7036-4d52-90ac-2b1b5be66354/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Richard</first_name>
          <last_name>Eisenberg</last_name>
          <affiliation>Bryn Mawr College</affiliation>
          <bio>Assistant Professor at Bryn Mawr College. I completed my PhD in 2016 at University of Pennsylvania working under Stephanie Weirich; my dissertation topic was the integration of dependent types into the Haskell programming language. I am a regular contributor to the Glasgow Haskell Compiler (GHC).</bio>
          <homepage_url>http://cs.brynmawr.edu/~rae</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/richardeisenberg/2d03068d-412f-453b-ac98-b41b80ec03ca/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Haskell</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>77e67792-2c7e-4369-8466-cd965b3d29d2</subevent_id>
    <title>Research Papers: Session 7</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/20</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>0599e6a6-4fd8-45d6-b4d8-4eb67335b8cc</slot_id>
      <title>Elaborator Reflection: Extending Idris in Idris</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>15:30</start_time>
      <end_time>15:55</end_time>
      <description>Many programming languages and proof assistants are defined by elaboration from a high-level language with a great deal of implicit information to a highly explicit core language. In many advanced languages, these elaboration facilities contain powerful tools for program construction, but these tools are rarely designed to be repurposed by users. We describe elaborator reflection, a paradigm for metaprogramming in which the elaboration machinery is made directly available to metaprograms, as well as a concrete realization of elaborator reflection in Idris, a functional language with full dependent types. We demonstrate the applicability of Idris's reflected elaboration framework to a number of realistic problems, we discuss the motivation for the specific features of its design, and we explore the broader meaning of elaborator reflection as it can relate to other languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Christiansen</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://davidchristiansen.dk</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/davidchristiansen/44c3b823-ddad-4b19-90d7-13f969bac6ab/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Brady</last_name>
          <affiliation>University of St. Andrews, UK</affiliation>
          <bio>Lecturer in Computer Science at the University of St Andrews</bio>
          <homepage_url>https://eb.host.cs.st-andrews.ac.uk/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/edwinbrady/80bf0399-ea88-42fd-b3bb-b3462f9d69b2/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2750acc7-bd8f-4cae-8dc6-6021d3d4717d</slot_id>
      <title>Unifiers as Equivalences: Proof-Relevant Unification of Dependently Typed Data</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>15:05</start_time>
      <end_time>15:30</end_time>
      <description>Dependently typed languages such as Agda, Coq and Idris use a syntactic first-order unification algorithm to check definitions by dependent pattern matching. However, these algorithms don’t adequately consider the types of the terms being unified, leading to various unintended results. As a consequence, they require ad hoc restrictions to preserve soundness, but this makes them very hard to prove correct, modify, or extend. 
This paper proposes a framework for reasoning formally about unification in a dependently typed setting. In this framework, unification rules compute not just a unifier but also a corresponding correctness proof in the form of an equivalence between two sets of equations. By rephrasing the standard unification rules in a proof-relevant manner, they are guaranteed to preserve soundness of the theory. In addition, it enables us to safely add new rules that can exploit the dependencies between the types of equations. 
Using our framework, we reimplemented the unification algorithm used by Agda. As a result, we were able to replace previous ad hoc restrictions with formally verified unification rules, fixing a number of bugs in the process. We are convinced this will also enable the addition of new and interesting unification rules in the future, without compromising soundness along the way.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jesper</first_name>
          <last_name>Cockx</last_name>
          <affiliation>iMinds, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://distrinet.cs.kuleuven.be/people/jesper</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/jespercockx/113f5ec5-aa52-443e-93e2-e7d8d136577b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominique</first_name>
          <last_name>Devriese</last_name>
          <affiliation>iMinds, Belgium</affiliation>
          <bio>My research interests are somewhat varied. I work on formalising properties of object-oriented and object-capability programming languages, specifically a property called effect parametricity. I am also interested in secure compilation and full abstraction properties and applying logical relations to prove them. Furthermore, I work on functional and dependently typed programming and programming languages. I have worked on a Haskell parsing library called grammar-combinators and have added instance arguments to the programming language/proof assistant Agda. I have also worked on information flow security, in particular a technique called secure multi-execution.</bio>
          <homepage_url>https://distrinet.cs.kuleuven.be/people/dominiqu</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/dominiquedevriese/986ff5db-c4f8-4f24-8384-d3f6b6328da0/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Piessens</last_name>
          <affiliation>iMinds, Belgium</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b87c383e-1df3-4b93-99e3-009a791c882e</slot_id>
      <title>Partial Type Equivalences for Verified Dependent Interoperability</title>
      <room>Noh Theater</room>
      <date>2016/09/20</date>
      <start_time>15:55</start_time>
      <end_time>16:20</end_time>
      <description>Full-spectrum dependent types promise to enable the development of correct-by-construction software. However, even certified software needs to interact with simply-typed or untyped programs, be it to perform system calls, or to use legacy libraries. Trading static guarantees for runtime checks, the dependent interoperability framework providesa mechanism by which simply-typed values can safely be coerced to dependent types and, conversely, dependently-typed programs can defensively be exported to a simply-typed application. In this paper, we give a semantic account of dependent interoperability. Our presentation relies on and is guided by a pervading notion of type equivalence, whose importance has been emphasized in recent work on homotopy type theory. Specifically, we develop the notion of partial type equivalences as a key foundation for dependent interoperability. Our framework is developed in Coq; it is thus constructive and verified in the strictest sense of the terms. Using our library, users can specify domain-specific partial equivalences between data structures. Our library then takes care of the (sometimes, heavy) lifting that leads to interoperable programs. It thus becomes possible, as we shall illustrate, to internalize and hand-tune the extraction of dependently-typed programs to interoperable OCaml programs within Coq itself.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pierre-Evariste</first_name>
          <last_name>Dagand</last_name>
          <affiliation>UPMC, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://pages.lip6.fr/Pierre-Evariste.Dagand/#contact</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/pierreevaristedagand/6c4733a2-2ea6-4600-98c6-d38e4e96fac3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Tabareau</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile, Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e8cb0e1a-4553-4360-9374-f98245f69c09</subevent_id>
    <title>Research Papers: Session 12</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/21</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>13cd25a4-2032-4bae-baf2-778ef3d7ec8f</slot_id>
      <title>Combining Effects and Coeffects via Grading</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>16:50</start_time>
      <end_time>17:15</end_time>
      <description>Effects and coeffects are two general, complementary aspects of program behaviour. They roughly correspond to computations which change the execution context (effects) versus computations which make demands on the context (coeffects). Effectful features include partiality, non-determinism, input-output, state, and exceptions. Coeffectful features include resource demands, variable access, notions of linearity, and data input requirements.The effectful or coeffectful behaviour of a program can be captured and described via type-based analyses, with fine grained information provided by monoidal effect annotations and semiring coeffects. Various recent work has proposed models for such typed calculi in terms of graded (strong) monads for effects and graded (monoidal) comonads for coeffects.Effects and coeffects have been studied separately so far, but in practice many computations are both effectful and coeffectful, e.g., possibly throwing exceptions but with resource requirements. To remedy this, we introduce a new general calculus with a combined effect-coeffect system. This can describe both the changes and requirements that a program has on its context, as well as interactions between these effectful and coeffectful features of computation. The effect-coeffect system has a denotational model in terms of effect-graded monads and coeffect-graded comonads where interaction is expressed via the novel concept of graded distributive laws. This graded semantics unifies the syntactic type theory with the denotational model. We show that our calculus can be instantiated to describe in a natural way various different kinds of interaction between a program and its evaluation context.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marco</first_name>
          <last_name>Gaboardi</last_name>
          <affiliation>SUNY Buffalo, USA</affiliation>
          <bio>Marco Gaboardi is an assistant professor in the Department of Computer Science and Engineering at the University at Buffalo, SUNY. Previously, he was a faculty at the University of Dundee, Scotland. He received his PhD from the University of Torino, Italy, and the Institute National Polytechnique de Lorraine, France. He was a visitor scholar at the University of Pennsylvania and at Harvard’s CRCS center. He has been the recipient of a EU Marie Curie Fellowship. His research is in programming languages, differential privacy, and logic.</bio>
          <homepage_url>http://www.buffalo.edu/~gaboardi</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/marcogaboardi/76ff8963-9672-4f16-87bc-3f0d75ce589b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shin-ya</first_name>
          <last_name>Katsumata</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.kurims.kyoto-u.ac.jp/~sinya/index-e.html</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/shinyakatsumata/5e61dcb3-bb87-442b-bbd6-0f9a566f939d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dominic</first_name>
          <last_name>Orchard</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>Dr Dominic Orchard is a Research Associate at the University of Cambridge and SSI Fellow. His research interests are programming language design and semantics, mathematically structured programming, effect and coeffect systems, embedded domain-specific languages (esp. for parallelisation), applying programming language research to computational science.</bio>
          <homepage_url>http://dorchard.co.uk</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/dominicorchard/f448aa26-a342-457c-91a6-3f9525a759a3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Flavien</first_name>
          <last_name>Breuvart</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tarmo</first_name>
          <last_name>Uustalu</last_name>
          <affiliation>Tallinn University of Technology, Estonia</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7d86edc9-9df4-4712-886c-043a18836356</slot_id>
      <title>String Diagrams for Free Monads (Functional Pearl)</title>
      <room>Noh Theater</room>
      <date>2016/09/21</date>
      <start_time>17:15</start_time>
      <end_time>17:40</end_time>
      <description>We show how one can reason about free monads using their universal properties rather than any concrete implementation. We introduce a graphical, two-dimensional calculus tailor-made to accommodate these properties.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maciej</first_name>
          <last_name>Piróg</last_name>
          <affiliation>KU Leuven, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~maciej.pirog/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/maciejpirog/6d35caec-bf73-4a63-b16b-9ee7f05d2a71/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Wu</last_name>
          <affiliation>University of Bristol, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>http://conf.researchr.org/getProfileImage/nicolaswu/b942d968-9bf7-4c15-9110-828a9d048664/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>19e147b9-dfa6-46b7-abdd-3b8c98d15af8</subevent_id>
    <title>Research Papers: Session 4</title>
    <subevent_type type="regular"/>
    <room>Noh Theater</room>
    <date>2016/09/19</date>
    <url>http://conf.researchr.org/track/icfp-2016/icfp-2016-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>6350c622-1ed3-4350-8294-5f5325850beb</slot_id>
      <title>All Sorts of Permutations (Functional Pearl)</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>17:50</start_time>
      <end_time>18:15</end_time>
      <description>The combination of non-determinism and sorting is mostly associated with permutation sort, a sorting algorithm that is not very useful for sorting and has an awful running time.In this paper we look at the combination of non-determinism and sorting in a different light: given a sorting function, we apply it to a non-deterministic predicate to gain a function that enumerates permutations of the input list. We get to the bottom of necessary properties of the sorting algorithms and predicates in play as well as discuss variations of the modelled non-determinism.On top of that, we formulate and prove a theorem stating that no matter which sorting function we use, the corresponding permutationfunction enumerates all permutations of the input list. We use free theorems, which are derived from the type of a functionalone, to prove the statement.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>Christiansen</last_name>
          <affiliation>Flensburg University of Applied Sciences, Germany</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nikita</first_name>
          <last_name>Danilenko</last_name>
          <affiliation>University of Kiel, Germany</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sandra</first_name>
          <last_name>Dylus</last_name>
          <affiliation>University of Kiel, Germany</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7241f2b3-8414-45a5-85ab-66d92ccf2607</slot_id>
      <title>Queueing and Glueing for Optimal Partitioning (Functional Pearl)</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>17:25</start_time>
      <end_time>17:50</end_time>
      <description>The queueing-glueing algorithm is the nickname we give to an algorithmic patternthat provides amortised linear time solutions to a number of optimal listpartition problems that have a peculiar property: at various moments we know thattwo of three candidate solutions could be optimal. The algorithm works bykeeping a queue of lists, glueing them from one end, while chopping from theother end, hence the name. We give a formal derivation of the algorithm, anddemonstrate it with several non-trivial examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shin-Cheng</first_name>
          <last_name>Mu</last_name>
          <affiliation>Academia Sinica, Taiwan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iis.sinica.edu.tw/~scm/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yu-Hsi</first_name>
          <last_name>Chiang</last_name>
          <affiliation>National Taiwan University, Taiwan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yu-Han</first_name>
          <last_name>Lyu</last_name>
          <affiliation>Dartmouth College, USA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ae472025-ffc4-44e3-946b-71c7b1c66ac7</slot_id>
      <title>Compact Bit Encoding Schemes for Simply-Typed Lambda-Terms</title>
      <room>Noh Theater</room>
      <date>2016/09/19</date>
      <start_time>17:00</start_time>
      <end_time>17:25</end_time>
      <description>We consider the problem of how to compactly encode simply-typed λ-terms into bit strings. The work has been motivated byKobayashi et al.'s recent work on higher-order data compression, where data are encoded as functional programs (or, λ-terms) that generate them. To exploit its good compression power,the compression scheme has to come with a method for compactly encodingthe λ-terms into bit strings. To this end, we propose two type-based bit-encoding schemes; the first one encodes a λ-term into a sequence of symbols by using type information, and then applies arithmetic coding to convert the sequence to a bit string. The second one is more sophisticated; we prepare a context-free grammar (CFG) that describes only well-typed terms, and then use a variation of arithmetic coding specialized for the CFG.We have implemented both schemes and confirmed that they oftenoutput more compact codes than previous bit encoding schemes for λ-terms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kotaro</first_name>
          <last_name>Takeda</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kazuya</first_name>
          <last_name>Yaguchi</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ayumi</first_name>
          <last_name>Shinohara</last_name>
          <affiliation>Tohoku University, Japan</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5ccaa694-65b6-4be1-b69f-1cce4e79e8dc</subevent_id>
    <title>FARM: Performance Evening</title>
    <subevent_type type="regular"/>
    <room>Live House Beverly Hills Restaurant</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/farm-2016-papers</url>
    <url_link_display>FARM</url_link_display>
    <tracks>
      <track>FARM</track>
    </tracks>
    <timeslot>
      <slot_id>18b34c9d-d1f0-44b5-a11a-aaaaaa47dfce</slot_id>
      <title>FARM 2016 Performance Evening</title>
      <room>Live House Beverly Hills Restaurant</room>
      <date>2016/09/24</date>
      <start_time>19:30</start_time>
      <end_time>21:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Renick</first_name>
          <last_name>Bell</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.renickbell.net/doku.php</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/renickbell/7a8eae2d-7872-493d-b999-ca6bb3aa2798/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0a78b94a-4391-4911-a275-78eab539cb17</subevent_id>
    <title>FARM: 5</title>
    <subevent_type type="regular"/>
    <room>Conference Room 3</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/farm-2016-papers</url>
    <url_link_display>FARM</url_link_display>
    <tracks>
      <track>FARM</track>
    </tracks>
    <timeslot>
      <slot_id>240f6bf4-f619-4f25-8c09-a3851295e0c6</slot_id>
      <title>Call for Collaboration: Computational Musicology, ????, Profit</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>15:20</start_time>
      <end_time>15:45</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chris</first_name>
          <last_name>Ford</last_name>
          <affiliation>ThoughtWorks (UK) Ltd.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.thoughtworks.com/de/profiles/chris-ford</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c117d0c6-0194-49d4-ab91-d4675fb26554</slot_id>
      <title>Demo: Alda: A text-based music composition language</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>15:45</start_time>
      <end_time>16:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dave</first_name>
          <last_name>Yarwood</last_name>
          <affiliation>Adzerk</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://blog.djy.io/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/daveyarwood/58676b3b-3e61-40db-b399-a6975b5ee375/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c35d0f97-0f88-448f-b7aa-8d824d071be9</subevent_id>
    <title>FARM: 2</title>
    <subevent_type type="regular"/>
    <room>Conference Room 3</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/farm-2016-papers</url>
    <url_link_display>FARM</url_link_display>
    <tracks>
      <track>FARM</track>
    </tracks>
    <timeslot>
      <slot_id>4b19dd8e-e80d-432b-92f5-28ad7a8b6a24</slot_id>
      <title>Demo: Juniper: A Functional Reactive Programming Language for the Arduino</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>10:35</start_time>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sam</first_name>
          <last_name>Guyer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Caleb</first_name>
          <last_name>Helbling</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8868231b-2b30-4d05-b796-7db38ba529cb</slot_id>
      <title>Juniper: A Functional Reactive Programming Language for the Arduino</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>11:00</start_time>
      <end_time>11:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Caleb</first_name>
          <last_name>Helbling</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Guyer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d9165022-b5dd-4cdc-8ea0-eb0ee65096bd</subevent_id>
    <title>FARM: 3</title>
    <subevent_type type="regular"/>
    <room>Conference Room 3</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/farm-2016-papers</url>
    <url_link_display>FARM</url_link_display>
    <tracks>
      <track>FARM</track>
    </tracks>
    <timeslot>
      <slot_id>0069e6e6-c7f9-49ad-bf69-e1831db5aa39</slot_id>
      <title>Arrp: A Functional Language with Multi-dimensional Signals and Recurrence Equations</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Leben</last_name>
          <affiliation>University of Victoria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mistic.finearts.uvic.ca/people/jakob-leben/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a29aafa9-3bcd-49dc-923c-26351b1d94d7</slot_id>
      <title>Demo: Klangmeister</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>12:10</start_time>
      <end_time>12:35</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chris</first_name>
          <last_name>Ford</last_name>
          <affiliation>ThoughtWorks (UK) Ltd.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.thoughtworks.com/de/profiles/chris-ford</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7487f369-6a78-428e-80f4-56ac99f427a1</subevent_id>
    <title>FARM: 6</title>
    <subevent_type type="regular"/>
    <room>Conference Room 3</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/farm-2016-papers</url>
    <url_link_display>FARM</url_link_display>
    <tracks>
      <track>FARM</track>
    </tracks>
    <timeslot>
      <slot_id>092c41aa-5a40-4b34-843f-155ee0e096c1</slot_id>
      <title>A Livecoding Semantics for Functional Reactive Programming</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>16:40</start_time>
      <end_time>17:20</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tom</first_name>
          <last_name>Murphy</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9a0bec97-6942-41d2-96ef-c87bc0e78301</slot_id>
      <title>Demo: Epimorphism</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>17:20</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Francis</first_name>
          <last_name>Shuman</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7afe1680-eccf-4b6d-bac3-d96ed3c216ed</subevent_id>
    <title>FARM: 4</title>
    <subevent_type type="regular"/>
    <room>Conference Room 3</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/farm-2016-papers</url>
    <url_link_display>FARM</url_link_display>
    <tracks>
      <track>FARM</track>
    </tracks>
    <timeslot>
      <slot_id>11f2143c-d76e-425e-a292-d6dcc8c87ac1</slot_id>
      <title>o.OM: Structured-Functional Communication between Computer Music Systems using OSC and Odot</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jean</first_name>
          <last_name>Bresson</last_name>
          <affiliation>UMR STMS: IRCAM-CNRS-UPMC</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://repmus.ircam.fr/bresson</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/jeanbresson/b1ba6718-1b7b-438d-95cc-69111f99dcb9/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>John</first_name>
          <last_name>MacCallum</last_name>
          <affiliation>CNMAT - UC Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://john-maccallum.com/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Freed</last_name>
          <affiliation>CNMAT - UC Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://tinkering.exploratorium.edu/adrian-freed</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1409be6e-f97e-4de2-9d93-add1ee34e3f2</slot_id>
      <title>Demo: VoxelCAD, a collaborative voxel-based CAD tool</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Csongor</first_name>
          <last_name>Kiss</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://kcsongor.github.io/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Toby</first_name>
          <last_name>Shaw</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~ts3314/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fac0f6fe-fa36-40db-bfe2-288a653450f6</subevent_id>
    <title>FARM: 1</title>
    <subevent_type type="regular"/>
    <room>Conference Room 3</room>
    <date>2016/09/24</date>
    <url>http://conf.researchr.org/track/icfp-2016/farm-2016-papers</url>
    <url_link_display>FARM</url_link_display>
    <tracks>
      <track>FARM</track>
    </tracks>
    <timeslot>
      <slot_id>85c7f6e1-73d3-4bb3-abf1-52ab2465e59e</slot_id>
      <title>Structured reactive programming with polymorphic temporal tiles</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>09:45</start_time>
      <end_time>10:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Archipoff</last_name>
          <affiliation>CNRS LaBRI, Inria Bordeaux,</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://scrime.labri.fr/blog/portfolio-item/simon-archipoff/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Janin</last_name>
          <affiliation>University of Bordeaux</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.labri.fr/perso/janin/</homepage_url>
          <picture_url>http://conf.researchr.org/getProfileImage/davidjanin/156a0aaf-9300-4ea3-8597-3cf733cda7b9/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dc5f1bcd-2038-41f4-ad78-29bfa9a3c450</slot_id>
      <title>Bithoven: Gödel Encoding of Chamber Music and Functional 8-Bit Audio Synthesis</title>
      <room>Conference Room 3</room>
      <date>2016/09/24</date>
      <start_time>09:15</start_time>
      <end_time>09:45</end_time>
      <description>.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jay</first_name>
          <last_name>McCarthy</last_name>
          <affiliation>University of Massachusetts Lowell</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jeapostrophe.github.io/home/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>FARM</track>
      </tracks>
    </timeslot>
  </subevent>
</event>
